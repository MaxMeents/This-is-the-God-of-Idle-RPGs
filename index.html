<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>God of Idle RPGs - Combat Prototype</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #050505;
            color: #fff;
            font-family: 'Segoe UI', sans-serif;
            background-image: none;
            /* Set dynamically */
            background-repeat: repeat;
            background-attachment: fixed;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #ffcc00;
            box-shadow: 0 0 20px rgba(255, 204, 0, 0.3);
            z-index: 100;
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: #ffcc00;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stat {
            font-family: monospace;
            font-size: 14px;
            margin-top: 10px;
            color: #00ff88;
        }

        .controls {
            font-size: 12px;
            margin-top: 15px;
            color: #aaa;
        }

        #player-health-container {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 30px;
            background: #fff;
            border: 4px solid #fff;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
            border-radius: 15px;
            overflow: hidden;
            z-index: 1000;
        }

        #player-health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #0096ff, #00d4ff);
            transition: width 0.1s ease-out;
        }
    </style>
</head>

<body>
    <div id="loading">Initializing Combat Engine...</div>
    <div id="ui">
        <h1>GOD OF IDLE RPGs</h1>
        <div id="count" class="stat">Tigers: 300</div>
        <div id="kills" class="stat">Kills: 0</div>
        <div id="fps" class="stat">FPS: 0</div>
        <div class="controls">
            [SCROLL] Zoom Camera<br>
            Player ball automatically hunts nearest tiger.<br>
            Screen follows player.
        </div>
    </div>
    <div id="player-health-container">
        <div id="player-health-bar"></div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        /**
         * God of Idle RPGs - Combat Engine Prototype
         * Focus: Automated Combat, Floating Damage Numbers, Optimized Data.
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: true });

        // CONFIG
        const Enemy = {
            Tiyger: {
                count: 0,
                size: 2500,
                healthMax: 35,
                moveSpeed: 15,
                spacing: 120,
                closestDist: 400,
                startDist: 10000,
                attackRange: 1500,
                damageMin: 25,
                damageMax: 100,
                walkPath: 'img/Figer Walking/Spritesheet/1024x1024/grok-video-c940ad13-8ea0-454d-8b91-76e181b1f208 (10)_1024x1024_sheet.png',
                deathPath: 'img/Figer Death/Spritesheet/512x512/Figer Death_512x512_sheet.png',
                attackPath: 'img/Fiyger Forward Attack/Spritesheet/512x512/Fiyger Forward Attack_512x512_sheet.png',
                walkFrames: 52, deathFrames: 145, attackFrames: 77,
                walkCols: 8, deathCols: 13, attackCols: 9,
                walkSize: 1024, deathSize: 512, attackSize: 512,
                walkAnimSpeed: 0.04, attackAnimSpeed: 4.0, deathAnimSpeed: 1.5,
                baseRotation: Math.PI, // Facing Right (PI rotation from Left base)
                isSideways: true
            },
            GalaxyDragon: {
                count: 7500,
                size: 3200,
                healthMax: 50,
                moveSpeed: 12,
                spacing: 200,
                closestDist: 600,
                startDist: 12000,
                attackRange: 2000,
                damageMin: 40,
                damageMax: 120,
                walkPath: 'img/Enemies/Galaxy Dragon/Galaxy Dragon Flying Forward/Spritesheet/512x512/Galaxy Dragon Flying Forward_512x512_sheet.png',
                deathPath: 'img/Enemies/Galaxy Dragon/Galaxy Dragon Flying Forward/Spritesheet/512x512/Galaxy Dragon Flying Forward_512x512_sheet.png',
                attackPath: 'img/Enemies/Galaxy Dragon/Galaxy Dragon Flying Forward/Spritesheet/512x512/Galaxy Dragon Flying Forward_512x512_sheet.png',
                walkFrames: 53, deathFrames: 53, attackFrames: 53,
                walkCols: 8, deathCols: 8, attackCols: 8,
                walkSize: 512, deathSize: 512, attackSize: 512, // Correct frame size from metadata
                walkAnimSpeed: 0.02, attackAnimSpeed: 1.0, deathAnimSpeed: 1.0,
                baseRotation: Math.PI / 2, // Facing North (Up)
                isSideways: false
            }
        };

        const totalEnemies = Enemy.Tiyger.count + Enemy.GalaxyDragon.count;
        const DAMAGE_PER_POP = 10;
        const DAMAGE_INTERVAL = 100; // ms
        const AOE_RADIUS = 900;
        const PLAYER_SPEED = 20;
        const FLOOR_PATH = 'img/Texture Floor/maxmaxmax_333_Ocean_temple_floor_tile_design_wave_patterns_biol_31b2bdc2-1580-4081-86b9-2f7b711e9005_1.png';
        const PLAYER_HEALTH_MAX = 35000;
        const MIN_ZOOM = 0.05;
        const MAX_ZOOM = 590.0;

        const PERFORMANCE = {
            // LOD Tiers sorted from Highest to Lowest quality
            // Resolution options: 2048, 1024, 768, 512, 256, 128, 64, 32, 16
            LOD_TIERS: [
                { id: 'Ultra', size: 2048, max: 15 },
                { id: 'High', size: 1024, max: 40 },
                { id: 'MidHigh', size: 768, max: 70 },
                { id: 'Med', size: 512, max: 120 },
                { id: 'MedLow', size: 256, max: 250 },
                { id: 'Low', size: 128, max: 500 },
                { id: 'VLow', size: 64, max: 1000 },
                { id: 'Tiny', size: 32, max: 2000 },
                { id: 'Micro', size: 16, max: 9999 }
            ],
            LOD_INIT_TIME_SLICE: 2, // ms per frame to dedicate to cache building
            SPAWNS_PER_FRAME: 100 // Prevent lag spikes on load/restart
        };

        let zoom = 0.35;
        let targetZoom = 0.35;
        const player = { x: 0, y: 0, targetIdx: -1, lastDamageTime: 0, health: PLAYER_HEALTH_MAX };
        let killCount = 0;
        let smoothedEnemies = 0;
        let spawnIndex = 0;
        const spawnList = [];

        // Data: [x, y, vx, vy, rot, frame, speed, look, health, deathFrame, attackFrame, typeIndex]
        const stride = 12;
        const data = new Float32Array(totalEnemies * stride);

        // Floating Numbers Pooled
        const damageNumbers = []; // {x, y, val, life}

        // Spatial Grid - High-capacity for massive titans
        const GRID_CELL = 4800; // GalaxyDragon.size * 1.5
        const GRID_DIM = 400;
        const heads = new Int32Array(GRID_DIM * GRID_DIM).fill(-1);
        const next = new Int32Array(totalEnemies);

        // High-Performance Tiered Caching
        const enemyAssets = {
            Tiyger: { walk: new Image(), death: new Image(), attack: new Image(), caches: { walk: {}, death: {}, attack: {} } },
            GalaxyDragon: { walk: new Image(), death: new Image(), attack: new Image(), caches: { walk: {}, death: {}, attack: {} } }
        };

        const floorImg = new Image();
        let floorPattern = null;

        function spawnEnemy(i, typeKey, far = false) {
            const cfg = Enemy[typeKey];
            const idx = i * stride;
            const angle = Math.random() * Math.PI * 2;
            const distBase = cfg.startDist + (Math.random() * cfg.startDist * 0.5);
            const dist = far ? distBase * 1.5 : distBase;

            data[idx] = player.x + Math.cos(angle) * dist;
            data[idx + 1] = player.y + Math.sin(angle) * dist;
            data[idx + 6] = cfg.moveSpeed * (0.8 + Math.random() * 0.4);
            data[idx + 8] = cfg.healthMax;
            data[idx + 9] = 0;
            data[idx + 5] = Math.random() * cfg.walkFrames;
            data[idx + 10] = 0;
            data[idx + 11] = typeKey === "Tiyger" ? 0 : 1;
        }

        function init(firstLoad = false) {
            player.health = PLAYER_HEALTH_MAX;
            player.x = 0; player.y = 0;
            killCount = 0;
            damageNumbers.length = 0;
            data.fill(0);
            spawnIndex = 0;

            if (firstLoad || spawnList.length === 0) {
                spawnList.length = 0;
                for (let i = 0; i < Enemy.Tiyger.count; i++) spawnList.push("Tiyger");
                for (let i = 0; i < Enemy.GalaxyDragon.count; i++) spawnList.push("GalaxyDragon");
            }

            if (firstLoad) document.getElementById('loading').style.display = 'none';
        }

        function softReset() {
            init(false);
            targetZoom = 0.35;
        }

        function buildEnemyCache(typeKey) {
            const cfg = Enemy[typeKey];
            const assets = enemyAssets[typeKey];
            const queue = [];

            // Add all animation/tier combinations to the queue
            for (let tier of PERFORMANCE.LOD_TIERS) {
                for (let type of ['walk', 'death', 'attack']) {
                    queue.push({
                        type,
                        tier,
                        frameCount: cfg[type + 'Frames'],
                        cols: cfg[type + 'Cols'],
                        sourceSize: cfg[type + 'Size'],
                        currentFrame: 0,
                        canvas: null
                    });
                }
            }

            // Process queue over several frames to prevent blocking
            const process = () => {
                const startTime = performance.now();
                while (queue.length > 0 && performance.now() - startTime < PERFORMANCE.LOD_INIT_TIME_SLICE) {
                    const task = queue[0];
                    const img = assets[task.type];

                    if (!task.canvas) {
                        task.canvas = document.createElement('canvas');
                        task.canvas.width = task.tier.size;
                        task.canvas.height = task.tier.size * task.frameCount;
                    }

                    const ctx = task.canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = true;

                    // Inner loop: process frames for this specific task until budget is exceeded
                    while (task.currentFrame < task.frameCount && performance.now() - startTime < PERFORMANCE.LOD_INIT_TIME_SLICE) {
                        const i = task.currentFrame;
                        const size = task.tier.size;
                        const srcX = (i % task.cols) * task.sourceSize;
                        const srcY = Math.floor(i / task.cols) * task.sourceSize;

                        ctx.drawImage(img, srcX, srcY, task.sourceSize, task.sourceSize, 0, i * size, size, size);
                        task.currentFrame++;
                    }

                    if (task.currentFrame >= task.frameCount) {
                        assets.caches[task.type][task.tier.id] = task.canvas;
                        queue.shift();
                    }
                }
                if (queue.length > 0) requestAnimationFrame(process);
            };
            requestAnimationFrame(process);
        }

        function update(dt, now) {
            if (player.health <= 0) return;

            for (let i = 0; i < PERFORMANCE.SPAWNS_PER_FRAME && spawnIndex < totalEnemies; i++) {
                spawnEnemy(spawnIndex, spawnList[spawnIndex], true);
                spawnIndex++;
            }

            zoom += (targetZoom - zoom) * 0.1;

            // Nearest Finding - only check spawned enemies
            let closestDist = Infinity;
            let found = -1;
            for (let i = 0; i < spawnIndex; i++) {
                const idx = i * stride;
                if (data[idx + 8] <= 0) continue;
                const dx = data[idx] - player.x, dy = data[idx + 1] - player.y;
                const dSq = dx * dx + dy * dy;
                if (dSq < closestDist) { closestDist = dSq; found = i; }
            }
            player.targetIdx = found;

            // Move to Current Nearest Target
            if (player.targetIdx !== -1) {
                const tIdx = player.targetIdx * stride;
                const dx = data[tIdx] - player.x;
                const dy = data[tIdx + 1] - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 10) {
                    player.x += (dx / dist) * PLAYER_SPEED;
                    player.y += (dy / dist) * PLAYER_SPEED;
                }

                if (now - player.lastDamageTime > DAMAGE_INTERVAL) {
                    player.lastDamageTime = now;
                    const rSq = AOE_RADIUS * AOE_RADIUS;
                    const px = player.x, py = player.y; // Player position for AOE
                    for (let i = 0; i < spawnIndex; i++) {
                        const idx = i * stride;
                        if (data[idx + 8] <= 0) continue;

                        const ddx = data[idx] - px;
                        const ddy = data[idx + 1] - py;
                        if (ddx * ddx + ddy * ddy < rSq) {
                            // Take Damage
                            data[idx + 8] -= DAMAGE_PER_POP;

                            // Pop Damage Number
                            damageNumbers.push({
                                x: data[idx],
                                y: data[idx + 1] - 50,
                                val: DAMAGE_PER_POP,
                                life: 1.0,
                                vx: (Math.random() - 0.5) * 2,
                                vy: -2 - Math.random() * 2
                            });

                            if (data[idx + 8] <= 0) {
                                killCount++;
                                // Initial death mark - start animation
                                data[idx + 8] = 0;
                                data[idx + 9] = 1; // Start death frame
                            }
                        }
                    }
                }
            }

            // --- PACK PHYSICS ---
            const gridOffset = (GRID_DIM * GRID_CELL) / 2;
            heads.fill(-1);
            for (let i = 0; i < spawnIndex; i++) {
                const idx = i * stride;
                if (data[idx + 8] <= 0) continue; // Skip unspawned/dead
                const gx = Math.floor((data[idx] - player.x + gridOffset) / GRID_CELL);
                const gy = Math.floor((data[idx + 1] - player.y + gridOffset) / GRID_CELL);
                const cIdx = gy * GRID_DIM + gx;
                if (cIdx >= 0 && cIdx < heads.length) {
                    next[i] = heads[cIdx];
                    heads[cIdx] = i;
                }
            }

            for (let i = 0; i < spawnIndex; i++) {
                const idx = i * stride;
                const typeKey = data[idx + 11] === 0 ? "Tiyger" : "GalaxyDragon";
                const cfg = Enemy[typeKey];

                if (data[idx + 8] <= 0) {
                    if (data[idx + 9] > 0) {
                        data[idx + 9] += cfg.deathAnimSpeed;
                        if (data[idx + 9] >= cfg.deathFrames) spawnEnemy(i, typeKey, true);
                    }
                    continue;
                }

                const px = data[idx], py = data[idx + 1];
                const dx = player.x - px, dy = player.y - py;
                const d = Math.sqrt(dx * dx + dy * dy);
                const look = Math.atan2(dy, dx);
                const lookX = Math.cos(look), lookY = Math.sin(look);

                const targetRadius = cfg.closestDist;
                const pSpace = cfg.size + cfg.spacing;
                const pSpaceSq = pSpace * pSpace;

                const distToTarget = Math.abs(d - targetRadius);
                const pullDir = d > targetRadius ? 1 : -0.5;
                let steerX = lookX * distToTarget * 0.5 * pullDir;
                let steerY = lookY * distToTarget * 0.5 * pullDir;

                const gx = Math.floor((px - player.x + gridOffset) / GRID_CELL);
                const gy = Math.floor((py - player.y + gridOffset) / GRID_CELL);
                let neighbors = 0;
                for (let ox = -1; ox <= 1; ox++) {
                    for (let oy = -1; oy <= 1; oy++) {
                        if (neighbors > 16) break; // Optimization: Cap neighbor checks
                        const cell = (gy + oy) * GRID_DIM + (gx + ox);
                        let nIdx = heads[cell];
                        while (nIdx !== -1) {
                            if (nIdx !== i) {
                                const oIdx = nIdx * stride;
                                const vx = px - data[oIdx], vy = py - data[oIdx + 1];
                                const dSq = vx * vx + vy * vy;
                                if (dSq < pSpaceSq && dSq > 0) {
                                    const dist = Math.sqrt(dSq);
                                    const force = ((pSpace - dist) / pSpace) * 40;
                                    steerX += (vx / dist) * force;
                                    steerY += (vy / dist) * force;
                                    neighbors++;
                                    if (neighbors > 16) break;
                                }
                            }
                            nIdx = next[nIdx];
                        }
                    }
                }

                // --- SETTLING FORWARD LOCK ---
                const dot = steerX * lookX + steerY * lookY;
                // Allow a small amount of backward movement to let the pack "settle"
                // but keep it primarily forward-facing.
                const backwardLimit = -2;
                if (dot < backwardLimit) {
                    steerX -= lookX * (dot - backwardLimit);
                    steerY -= lookY * (dot - backwardLimit);
                }

                const mag = Math.sqrt(steerX * steerX + steerY * steerY);
                if (mag > 0.1) {
                    const speed = Math.min(data[idx + 6] * 2, mag * 20);
                    const moveAngle = Math.atan2(steerY, steerX);
                    data[idx] += Math.cos(moveAngle) * speed;
                    data[idx + 1] += Math.sin(moveAngle) * speed;
                    data[idx + 7] = look;
                    data[idx + 4] = look + cfg.baseRotation;
                    data[idx + 5] = (mag > 0.3) ? (data[idx + 5] + speed * cfg.walkAnimSpeed) % cfg.walkFrames : 0;
                } else {
                    data[idx + 5] = 0;
                    if (d < cfg.attackRange * 1.5) { data[idx + 7] = look; data[idx + 4] = look + cfg.baseRotation; }
                }

                // --- ATTACK LOGIC ---
                if (d < cfg.attackRange && data[idx + 8] > 0) {
                    if (data[idx + 10] === 0) data[idx + 10] = 0.1;
                    else {
                        const prevF = Math.floor(data[idx + 10]);
                        data[idx + 10] += cfg.attackAnimSpeed;
                        const currF = Math.floor(data[idx + 10]);
                        if (prevF < (cfg.attackFrames / 2) && currF >= (cfg.attackFrames / 2)) {
                            player.health -= cfg.damageMin + Math.random() * (cfg.damageMax - cfg.damageMin);
                            if (player.health < 0) {
                                player.health = 0;
                                setTimeout(softReset, 1000);
                            }
                        }
                        if (data[idx + 10] >= cfg.attackFrames) data[idx + 10] = 0.1;
                    }
                } else { data[idx + 10] = 0; }
            }

            // Update UI
            document.getElementById('player-health-bar').style.width = (player.health / PLAYER_HEALTH_MAX * 100) + '%';

            // Update Damage Numbers
            for (let i = damageNumbers.length - 1; i >= 0; i--) {
                const dn = damageNumbers[i];
                dn.x += dn.vx; dn.y += dn.vy; dn.life -= 0.02;
                if (dn.life <= 0) damageNumbers.splice(i, 1);
            }

            document.getElementById('kills').innerText = `Kills: ${killCount}`;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Sync CSS Background for Zero-Cost Tile Overheads
            if (floorPattern) {
                const bgSize = 1024 * zoom; // Assuming base tile is ~1024px or similar
                const bgX = -player.x * zoom + (canvas.width / 2);
                const bgY = -player.y * zoom + (canvas.height / 2);
                document.body.style.backgroundPosition = `${bgX}px ${bgY}px`;
                document.body.style.backgroundSize = `${bgSize}px`;
            }

            const cx = canvas.width / 2, cy = canvas.height / 2;
            ctx.save();
            ctx.translate(cx, cy);
            ctx.scale(zoom, zoom);
            ctx.translate(-player.x, -player.y);

            // Culling bounds (+100px margin)
            const margin = 100 + (Math.max(Enemy.Tiyger.size, Enemy.GalaxyDragon.size) / 2);
            const left = player.x - (cx / zoom) - margin;
            const right = player.x + (cx / zoom) + margin;
            const top = player.y - (cy / zoom) - margin;
            const bottom = player.y + (cy / zoom) + margin;

            // Background Tile Texture (Handled by CSS)

            // Dynamic LOD Selection (Exact On-Screen Count + Smoothing)
            let onScreen = 0;
            for (let i = 0; i < spawnIndex; i++) {
                const idx = i * stride;
                if (data[idx + 8] <= 0 && data[idx + 9] <= 0) continue;
                if (data[idx] > left && data[idx] < right && data[idx + 1] > top && data[idx + 1] < bottom) onScreen++;
            }

            // Apply smoothing to prevent resolution flicker
            smoothedEnemies += (onScreen - smoothedEnemies) * 0.1;

            let activeTier = PERFORMANCE.LOD_TIERS[PERFORMANCE.LOD_TIERS.length - 1];
            for (let tier of PERFORMANCE.LOD_TIERS) {
                if (smoothedEnemies <= tier.max) {
                    activeTier = tier;
                    break;
                }
            }
            const currentSize = activeTier.size;
            const tierID = activeTier.id;

            for (let i = 0; i < spawnIndex; i++) {
                const idx = i * stride;
                const x = data[idx], y = data[idx + 1];
                if (x < left || x > right || y < top || y > bottom) continue;

                const rot = data[idx + 4], frame = Math.floor(data[idx + 5]), look = data[idx + 7];
                const health = data[idx + 8], deathFrame = Math.floor(data[idx + 9]), attackFrame = Math.floor(data[idx + 10]);
                const typeKey = data[idx + 11] === 0 ? "Tiyger" : "GalaxyDragon";
                const cfg = Enemy[typeKey], assets = enemyAssets[typeKey];

                ctx.setTransform(zoom * Math.cos(rot), zoom * Math.sin(rot), -zoom * Math.sin(rot), zoom * Math.cos(rot), cx + (x - player.x) * zoom, cy + (y - player.y) * zoom);
                if (cfg.isSideways && Math.abs(look) < Math.PI / 2) ctx.scale(1, -1);

                // Safe Tier Fallback (check if cache is ready)
                const getReadyCache = (key) => {
                    const group = assets.caches[key];
                    if (group[tierID]) return { canvas: group[tierID], size: currentSize };
                    // fallback to any ready tier
                    for (let t of PERFORMANCE.LOD_TIERS) {
                        if (group[t.id]) return { canvas: group[t.id], size: t.size };
                    }
                    return null;
                };

                if (health > 0) {
                    if (attackFrame > 0) {
                        const ready = getReadyCache('attack');
                        if (ready) {
                            const safeF = Math.min(cfg.attackFrames - 1, attackFrame);
                            ctx.drawImage(ready.canvas, 0, safeF * ready.size, ready.size, ready.size, -cfg.size / 2, -cfg.size / 2, cfg.size, cfg.size);
                        }
                    } else {
                        const ready = getReadyCache('walk');
                        if (ready) {
                            const safeF = Math.min(cfg.walkFrames - 1, frame);
                            ctx.drawImage(ready.canvas, 0, safeF * ready.size, ready.size, ready.size, -cfg.size / 2, -cfg.size / 2, cfg.size, cfg.size);
                        }
                    }
                } else if (deathFrame > 0) {
                    const ready = getReadyCache('death');
                    if (ready) {
                        const alpha = Math.max(0, 1 - (deathFrame / cfg.deathFrames - 0.7) * 3);
                        ctx.globalAlpha = alpha;
                        const safeF = Math.min(cfg.deathFrames - 1, deathFrame);
                        ctx.drawImage(ready.canvas, 0, safeF * ready.size, ready.size, ready.size, -cfg.size / 2, -cfg.size / 2, cfg.size, cfg.size);
                        ctx.globalAlpha = 1.0;
                    }
                }
            }

            // Player Visual
            ctx.setTransform(zoom, 0, 0, zoom, cx, cy);
            ctx.beginPath(); ctx.arc(0, 0, 80, 0, Math.PI * 2);
            ctx.fillStyle = "#0ff"; ctx.shadowColor = "#0ff"; ctx.shadowBlur = 40; ctx.fill();
            ctx.shadowBlur = 0;

            // Damage Numbers
            ctx.setTransform(1, 0, 0, 1, 0, 0); // UI relative to screen
            ctx.font = "bold 24px Arial";
            for (const dn of damageNumbers) {
                const sx = (dn.x - player.x) * zoom + cx;
                const sy = (dn.y - player.y) * zoom + cy;
                ctx.fillStyle = `rgba(255, 0, 0, ${dn.life})`;
                ctx.fillText(dn.val, sx, sy);
            }
            ctx.restore();
        }

        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
        window.addEventListener('wheel', (e) => { targetZoom *= e.deltaY > 0 ? 0.9 : 1.1; targetZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, targetZoom)); });

        let loadedCt = 0;
        const totalToLoad = 7; // T(3) + GD(3) + Floor(1)
        function onAssetLoad() {
            loadedCt++;
            if (loadedCt === totalToLoad) {
                document.body.style.backgroundImage = `url("${FLOOR_PATH}")`;
                floorPattern = true;
                buildEnemyCache("Tiyger");
                buildEnemyCache("GalaxyDragon");
                init(true);
                canvas.width = window.innerWidth; canvas.height = window.innerHeight;
                let last = 0, f = 0, t = 0;
                function loop(now) {
                    const dt = now - last; last = now;
                    t += dt; f++;
                    if (t > 1000) { document.getElementById('fps').innerText = `FPS: ${f}`; f = 0; t = 0; }
                    update(dt, now); draw(); requestAnimationFrame(loop);
                }
                requestAnimationFrame(loop);
            }
        }

        const load = (path, img) => { img.onload = onAssetLoad; img.src = path; };
        load(Enemy.Tiyger.walkPath, enemyAssets.Tiyger.walk);
        load(Enemy.Tiyger.deathPath, enemyAssets.Tiyger.death);
        load(Enemy.Tiyger.attackPath, enemyAssets.Tiyger.attack);
        load(Enemy.GalaxyDragon.walkPath, enemyAssets.GalaxyDragon.walk);
        load(Enemy.GalaxyDragon.deathPath, enemyAssets.GalaxyDragon.death);
        load(Enemy.GalaxyDragon.attackPath, enemyAssets.GalaxyDragon.attack);
        load(FLOOR_PATH, floorImg);
    </script>
</body>

</html>