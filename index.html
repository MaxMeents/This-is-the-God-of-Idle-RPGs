<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>God of Idle RPGs - Combat Prototype</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #050505;
            color: #fff;
            font-family: 'Segoe UI', sans-serif;
            background-image: none;
            /* Set dynamically */
            background-repeat: repeat;
            background-attachment: fixed;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #ffcc00;
            box-shadow: 0 0 20px rgba(255, 204, 0, 0.3);
            z-index: 100;
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: #ffcc00;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stat {
            font-family: monospace;
            font-size: 14px;
            margin-top: 10px;
            color: #00ff88;
        }

        .controls {
            font-size: 12px;
            margin-top: 15px;
            color: #aaa;
        }

        #player-health-container {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 30px;
            background: #fff;
            border: 4px solid #fff;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
            border-radius: 15px;
            overflow: hidden;
            z-index: 1000;
        }

        #player-health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #0096ff, #00d4ff);
            transition: width 0.1s ease-out;
        }

        #speed-ctrl-container {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.2);
            z-index: 100;
            pointer-events: auto;
            width: 200px;
        }

        .speed-label {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #00ff88;
            margin-bottom: 8px;
            font-weight: bold;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
            accent-color: #00ff88;
        }
    </style>
</head>

<body>
    <div id="loading">Initializing Combat Engine...</div>
    <div id="ui">
        <h1>GOD OF IDLE RPGs</h1>
        <div id="count" class="stat">Tigers: 300</div>
        <div id="kills" class="stat">Kills: 0</div>
        <div id="fps" class="stat">FPS: 0</div>
        <div class="controls">
            [SCROLL] Zoom Camera<br>
            Player ball automatically hunts nearest tiger.<br>
            Screen follows player.
        </div>
    </div>
    <div id="speed-ctrl-container">
        <div class="speed-label">
            <span>GAME SPEED</span>
            <span id="speed-val">1.0x</span>
        </div>
        <input type="range" id="speed-slider" min="1" max="20" step="1" value="1">
    </div>
    <div id="player-health-container">
        <div id="player-health-bar"></div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        /**
         * God of Idle RPGs - Combat Engine Prototype
         * Focus: Automated Combat, Floating Damage Numbers, Optimized Data.
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: true });

        // CONFIG
        const Enemy = {
            Tiyger: {
                count: 0, // Default lower for broad compatibility, but scales to 10k
                size: 2500,
                healthMax: 35,
                moveSpeed: 15,
                spacing: 120,
                closestDist: 400,
                startDist: 10000,
                attackRange: 1500,
                damageMin: 25,
                damageMax: 100,
                walkPath: 'img/Figer Walking/Spritesheet/1024x1024/grok-video-c940ad13-8ea0-454d-8b91-76e181b1f208 (10)_1024x1024_sheet.png',
                deathPath: 'img/Figer Death/Spritesheet/512x512/Figer Death_512x512_sheet.png',
                attackPath: 'img/Fiyger Forward Attack/Spritesheet/512x512/Fiyger Forward Attack_512x512_sheet.png',
                walkFrames: 52, deathFrames: 145, attackFrames: 77,
                walkCols: 8, deathCols: 13, attackCols: 9,
                walkSize: 1024, deathSize: 512, attackSize: 512,
                walkAnimSpeed: 0.04, attackAnimSpeed: 4.0, deathAnimSpeed: 1.5,
                baseRotation: Math.PI, // Facing Right (PI rotation from Left base)
                isSideways: true
            },
            GalaxyDragon: {
                count: 1000,
                size: 3200,
                healthMax: 50,
                moveSpeed: 12,
                spacing: 200,
                closestDist: 600,
                startDist: 12000,
                attackRange: 2000,
                damageMin: 40,
                damageMax: 120,
                walkPath: 'img/Enemies/Galaxy Dragon/Galaxy Dragon Flying Forward/Spritesheet/512x512/Galaxy Dragon Flying Forward_512x512_sheet.png',
                deathPath: 'img/Enemies/Galaxy Dragon/Galaxy Dragon Flying Forward/Spritesheet/512x512/Galaxy Dragon Flying Forward_512x512_sheet.png',
                attackPath: 'img/Enemies/Galaxy Dragon/Galaxy Dragon Flying Forward/Spritesheet/512x512/Galaxy Dragon Flying Forward_512x512_sheet.png',
                walkFrames: 53, deathFrames: 53, attackFrames: 53,
                walkCols: 8, deathCols: 8, attackCols: 8,
                walkSize: 512, deathSize: 512, attackSize: 512, // Correct frame size from metadata
                walkAnimSpeed: 0.02, attackAnimSpeed: 1.0, deathAnimSpeed: 1.0,
                baseRotation: Math.PI / 2, // Facing North (Up)
                isSideways: false
            }
        };

        const totalEnemies = Enemy.Tiyger.count + Enemy.GalaxyDragon.count;
        const DAMAGE_PER_POP = 10;
        const DAMAGE_INTERVAL = 100; // ms
        const AOE_RADIUS = 900;
        const PLAYER_SPEED = 20;
        const FLOOR_PATH = 'img/Texture Floor/maxmaxmax_333_Ocean_temple_floor_tile_design_wave_patterns_biol_31b2bdc2-1580-4081-86b9-2f7b711e9005_1.png';
        const PLAYER_HEALTH_MAX = 35000;
        const MIN_ZOOM = 0.05;
        const MAX_ZOOM = 590.0;

        const PERFORMANCE = {
            // LOD Tiers sorted from Highest to Lowest quality
            LOD_TIERS: [
                { id: 'Ultra', size: 1024, max: 15 },
                { id: 'High', size: 1024, max: 40 },
                { id: 'MidHigh', size: 768, max: 70 },
                { id: 'Med', size: 512, max: 120 },
                { id: 'MedLow', size: 256, max: 250 },
                { id: 'Low', size: 128, max: 500 },
                { id: 'VLow', size: 64, max: 1000 },
                { id: 'Tiny', size: 32, max: 2000 },
                { id: 'Micro', size: 16, max: 9999 }
            ],
            LOD_INIT_TIME_SLICE: 1, // ms per frame
            SPAWNS_PER_FRAME: 50,
            GAME_SPEED: 1.0 // Can be set up to 20.0
        };

        let zoom = 0.35;
        let targetZoom = 0.35;
        const player = { x: 0, y: 0, targetIdx: -1, lastDamageTime: 0, health: PLAYER_HEALTH_MAX };
        let killCount = 0;
        let smoothedEnemies = 0;
        let onScreenCount = 0;
        let spawnIndex = 0;
        const spawnList = [];

        // Data: [x, y, vx, vy, rot, frame, speed, look, health, deathFrame, attackFrame, typeIndex]
        const stride = 12;
        const data = new Float32Array(totalEnemies * stride);

        // Floating Numbers Pooled
        const damageNumbers = []; // {x, y, val, life}

        // Spatial Grid
        const GRID_CELL = 4800;
        const GRID_DIM = 400;
        const heads = new Int32Array(GRID_DIM * GRID_DIM).fill(-1);
        const next = new Int32Array(totalEnemies);
        const occupiedCells = new Int32Array(GRID_DIM * GRID_DIM); // Track which cells to clear
        let occupiedCount = 0;

        // High-Performance Tiered Caching
        const enemyAssets = {
            Tiyger: { walk: new Image(), death: new Image(), attack: new Image(), caches: { walk: {}, death: {}, attack: {} } },
            GalaxyDragon: { walk: new Image(), death: new Image(), attack: new Image(), caches: { walk: {}, death: {}, attack: {} } }
        };

        const floorImg = new Image();
        let floorPattern = null;

        function spawnEnemy(i, typeKey, far = false) {
            const cfg = Enemy[typeKey];
            const idx = i * stride;
            const angle = Math.random() * Math.PI * 2;
            const distBase = cfg.startDist + (Math.random() * cfg.startDist * 0.5);
            const dist = far ? distBase * 1.5 : distBase;

            data[idx] = player.x + Math.cos(angle) * dist;
            data[idx + 1] = player.y + Math.sin(angle) * dist;
            data[idx + 6] = cfg.moveSpeed * (0.8 + Math.random() * 0.4);
            data[idx + 8] = cfg.healthMax;
            data[idx + 9] = 0;
            data[idx + 5] = Math.random() * cfg.walkFrames;
            data[idx + 10] = 0;
            data[idx + 11] = typeKey === "Tiyger" ? 0 : 1;
        }

        function init(firstLoad = false) {
            player.health = PLAYER_HEALTH_MAX;
            player.x = 0; player.y = 0;
            killCount = 0;
            damageNumbers.length = 0;
            data.fill(0);
            spawnIndex = 0;

            if (firstLoad || spawnList.length === 0) {
                spawnList.length = 0;
                for (let i = 0; i < Enemy.Tiyger.count; i++) spawnList.push("Tiyger");
                for (let i = 0; i < Enemy.GalaxyDragon.count; i++) spawnList.push("GalaxyDragon");
            }

            if (firstLoad) document.getElementById('loading').style.display = 'none';
        }

        function softReset() {
            init(false);
            targetZoom = 0.35;
        }

        // Global Cache Manager
        // Hybrid Cache Manager: Uses Worker if possible, or a non-blocking Main Thread loop otherwise.
        let workerTasksCount = 0;
        let isWorkerSafe = false;

        const bakerWorker = (() => {
            // file:// protocol blocks ImageBitmap cloning for security. 
            // Disable worker for local files to avoid DataCloneError.
            if (window.location.protocol === 'file:') return null;

            try {
                const blob = new Blob([`
                    self.onmessage = async (e) => {
                        const { typeKey, animType, sheet, tier, frameCount, cols, sourceSize } = e.data;
                        const results = [];
                        const size = tier.size;
                        for (let i = 0; i < frameCount; i++) {
                            const canvas = new OffscreenCanvas(size, size);
                            const ctx = canvas.getContext('2d');
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(sheet, (i % cols) * sourceSize, Math.floor(i / cols) * sourceSize, sourceSize, sourceSize, 0, 0, size, size);
                            results.push(canvas.transferToImageBitmap());
                        }
                        self.postMessage({ typeKey, animType, tierID: tier.id, results }, results);
                    };
                `], { type: 'application/javascript' });
                const w = new Worker(URL.createObjectURL(blob));
                isWorkerSafe = true;
                return w;
            } catch (e) {
                console.warn("[Baker] Worker disabled.");
                return null;
            }
        })();

        if (bakerWorker) {
            bakerWorker.onmessage = (e) => {
                const { typeKey, animType, tierID, results } = e.data;
                enemyAssets[typeKey].caches[animType][tierID] = results;
                workerTasksCount--;
            };
        }

        const fallbackQueue = [];
        let isFallbackRunning = false;
        const bakedStatus = {};
        const inQueue = new Set();

        function runFallbackBaker() {
            if (fallbackQueue.length === 0) { isFallbackRunning = false; return; }
            isFallbackRunning = true;

            // Only sort when a new high-priority request comes in, not every tick
            if (needsSort) {
                fallbackQueue.sort((a, b) => {
                    const aNeeded = (a.typeKey === lastRequestedType && a.tier.id === lastRequestedTier) ? 0 : 1;
                    const bNeeded = (b.typeKey === lastRequestedType && b.tier.id === lastRequestedTier) ? 0 : 1;
                    return aNeeded - bNeeded || a.tier.size - b.tier.size;
                });
                needsSort = false;
            }

            const startTime = performance.now();
            while (fallbackQueue.length > 0 && (performance.now() - startTime < 2)) {
                const task = fallbackQueue[0];
                const assets = enemyAssets[task.typeKey];
                if (!assets.caches[task.animType][task.tier.id]) assets.caches[task.animType][task.tier.id] = [];

                const i = task.currentFrame;
                const canvas = document.createElement('canvas');
                canvas.width = task.tier.size; canvas.height = task.tier.size;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.drawImage(assets[task.animType], (i % task.cols) * task.sourceSize, Math.floor(i / task.cols) * task.sourceSize, task.sourceSize, task.sourceSize, 0, 0, task.tier.size, task.tier.size);

                assets.caches[task.animType][task.tier.id][i] = canvas;
                task.currentFrame++;

                if (task.currentFrame >= task.frameCount) {
                    if (!bakedStatus[task.typeKey]) bakedStatus[task.typeKey] = {};
                    if (!bakedStatus[task.typeKey][task.animType]) bakedStatus[task.typeKey][task.animType] = {};
                    bakedStatus[task.typeKey][task.animType][task.tier.id] = true;

                    inQueue.delete(`${task.typeKey}:${task.animType}:${task.tier.id}`);
                    fallbackQueue.shift();
                    workerTasksCount--;
                    readyMapDirty = true; // Signal the draw loop to update its pointers
                }
            }
            if (fallbackQueue.length > 0) setTimeout(runFallbackBaker, 10);
            else isFallbackRunning = false;
        }

        let lastRequestedType = null;
        let lastRequestedTier = null;
        let needsSort = false;
        let readyMapDirty = true;

        async function buildEnemyCache(typeKey, fullBake = false) {
            const cfg = Enemy[typeKey];
            const tiersToQueue = fullBake ? PERFORMANCE.LOD_TIERS : PERFORMANCE.LOD_TIERS.filter(t => t.size <= 128);

            for (let tier of tiersToQueue) {
                ['walk', 'death', 'attack'].forEach(anim => {
                    const key = `${typeKey}:${anim}:${tier.id}`;
                    if (bakedStatus[typeKey]?.[anim]?.[tier.id] || inQueue.has(key)) return;

                    workerTasksCount++;
                    inQueue.add(key);
                    fallbackQueue.push({ typeKey, animType: anim, tier, frameCount: cfg[anim + 'Frames'], cols: cfg[anim + 'Cols'], sourceSize: cfg[anim + 'Size'], currentFrame: 0 });
                });
            }
            needsSort = true;
            if (!isFallbackRunning) runFallbackBaker();
        }

        function ensureTierBaking(typeKey, tierID) {
            if (lastRequestedType === typeKey && lastRequestedTier === tierID) return;
            const tier = PERFORMANCE.LOD_TIERS.find(t => t.id === tierID);
            if (!tier) return;

            lastRequestedType = typeKey;
            lastRequestedTier = tierID;
            needsSort = true;

            const cfg = Enemy[typeKey];
            ['walk', 'death', 'attack'].forEach(anim => {
                const key = `${typeKey}:${anim}:${tier.id}`;
                if (bakedStatus[typeKey]?.[anim]?.[tier.id] || inQueue.has(key)) return;

                workerTasksCount++;
                inQueue.add(key);
                fallbackQueue.push({ typeKey, animType: anim, tier, frameCount: cfg[anim + 'Frames'], cols: cfg[anim + 'Cols'], sourceSize: cfg[anim + 'Size'], currentFrame: 0 });
            });
            if (!isFallbackRunning) runFallbackBaker();
        }

        function update(dt, now) {
            if (player.health <= 0) return;

            for (let i = 0; i < PERFORMANCE.SPAWNS_PER_FRAME && spawnIndex < totalEnemies; i++) {
                spawnEnemy(spawnIndex, spawnList[spawnIndex], true);
                spawnIndex++;
            }

            zoom += (targetZoom - zoom) * 0.1;

            // 1. CLEAR AND REBUILD GRID FIRST (Used for Physics AND Targeting)
            const gridOffset = (GRID_DIM * GRID_CELL) / 2;
            for (let i = 0; i < occupiedCount; i++) heads[occupiedCells[i]] = -1;
            occupiedCount = 0;

            for (let i = 0; i < spawnIndex; i++) {
                const idx = i * stride;
                if (data[idx + 8] <= 0) continue;
                const gx = Math.floor((data[idx] - player.x + gridOffset) / GRID_CELL);
                const gy = Math.floor((data[idx + 1] - player.y + gridOffset) / GRID_CELL);
                const cIdx = gy * GRID_DIM + gx;
                if (cIdx >= 0 && cIdx < heads.length) {
                    if (heads[cIdx] === -1) occupiedCells[occupiedCount++] = cIdx;
                    next[i] = heads[cIdx];
                    heads[cIdx] = i;
                }
            }

            // 2. Spatial Nearest Finding (Only every few steps or every frame for performance)
            if (now - (player.lastTargetTime || 0) > 100) {
                player.lastTargetTime = now;
                let closestDist = Infinity;
                let found = -1;
                const searchRadius = 2; // Cells
                const pgx = Math.floor(gridOffset / GRID_CELL);
                const pgy = Math.floor(gridOffset / GRID_CELL);

                for (let ox = -searchRadius; ox <= searchRadius; ox++) {
                    for (let oy = -searchRadius; oy <= searchRadius; oy++) {
                        let ptr = heads[(pgy + oy) * GRID_DIM + (pgx + ox)];
                        while (ptr !== -1) {
                            const idx = ptr * stride;
                            const dx = data[idx] - player.x, dy = data[idx + 1] - player.y;
                            const dSq = dx * dx + dy * dy;
                            if (dSq < closestDist) { closestDist = dSq; found = ptr; }
                            ptr = next[ptr];
                        }
                    }
                }
                player.targetIdx = found;
            }

            // 3. Movement and AOE Logic
            if (player.targetIdx !== -1) {
                const tIdx = player.targetIdx * stride;
                const dx = data[tIdx] - player.x;
                const dy = data[tIdx + 1] - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 10) {
                    player.x += (dx / dist) * PLAYER_SPEED;
                    player.y += (dy / dist) * PLAYER_SPEED;
                }

                if (now - player.lastDamageTime > DAMAGE_INTERVAL) {
                    player.lastDamageTime = now;
                    const rSq = AOE_RADIUS * AOE_RADIUS;
                    const pgx = Math.floor(gridOffset / GRID_CELL);
                    const pgy = Math.floor(gridOffset / GRID_CELL);
                    const rCell = Math.ceil(AOE_RADIUS / GRID_CELL);

                    for (let ox = -rCell; ox <= rCell; ox++) {
                        for (let oy = -rCell; oy <= rCell; oy++) {
                            let ptr = heads[(pgy + oy) * GRID_DIM + (pgx + ox)];
                            while (ptr !== -1) {
                                const idx = ptr * stride;
                                if (data[idx + 8] <= 0) { ptr = next[ptr]; continue; }
                                const ddx = data[idx] - player.x, ddy = data[idx + 1] - player.y;
                                if (ddx * ddx + ddy * ddy < rSq) {
                                    data[idx + 8] -= DAMAGE_PER_POP;

                                    if (damageNumbers.length < 100) {
                                        damageNumbers.push({ x: data[idx], y: data[idx + 1] - 50, val: DAMAGE_PER_POP, life: 1.0, vx: (Math.random() - 0.5) * 2, vy: -2 - Math.random() * 2 });
                                    }

                                    if (data[idx + 8] <= 0) { killCount++; data[idx + 8] = 0; data[idx + 9] = 1; }
                                }
                                ptr = next[ptr];
                            }
                        }
                    }
                }
            }

            for (let i = 0; i < spawnIndex; i++) {
                const idx = i * stride;
                const typeKey = data[idx + 11] === 0 ? "Tiyger" : "GalaxyDragon";
                const cfg = Enemy[typeKey];

                if (data[idx + 8] <= 0) {
                    if (data[idx + 9] > 0) {
                        data[idx + 9] += cfg.deathAnimSpeed;
                        if (data[idx + 9] >= cfg.deathFrames) spawnEnemy(i, typeKey, true);
                    }
                    continue;
                }

                const px = data[idx], py = data[idx + 1];
                const dx = player.x - px, dy = player.y - py;
                const d = Math.sqrt(dx * dx + dy * dy);
                const look = Math.atan2(dy, dx);
                const lookX = Math.cos(look), lookY = Math.sin(look);

                const targetRadius = cfg.closestDist;
                const pSpace = cfg.size + cfg.spacing;
                const pSpaceSq = pSpace * pSpace;

                const distToTarget = Math.abs(d - targetRadius);
                const pullDir = d > targetRadius ? 1 : -0.5;
                let steerX = lookX * distToTarget * 0.5 * pullDir;
                let steerY = lookY * distToTarget * 0.5 * pullDir;

                const gx = Math.floor((px - player.x + gridOffset) / GRID_CELL);
                const gy = Math.floor((py - player.y + gridOffset) / GRID_CELL);
                let neighbors = 0;
                const NEIGHBOR_CAP = 8; // Tighter cap for 10k enemies

                for (let ox = -1; ox <= 1; ox++) {
                    for (let oy = -1; oy <= 1; oy++) {
                        if (neighbors > NEIGHBOR_CAP) break;
                        const cell = (gy + oy) * GRID_DIM + (gx + ox);
                        if (cell < 0 || cell >= heads.length) continue;
                        let nIdx = heads[cell];
                        while (nIdx !== -1) {
                            if (nIdx !== i) {
                                const oIdx = nIdx * stride;
                                const vx = px - data[oIdx], vy = py - data[oIdx + 1];
                                const dSq = vx * vx + vy * vy;
                                if (dSq < pSpaceSq && dSq > 0) {
                                    const dist = Math.sqrt(dSq);
                                    const force = ((pSpace - dist) / pSpace) * 40;
                                    steerX += (vx / dist) * force;
                                    steerY += (vy / dist) * force;
                                    neighbors++;
                                    if (neighbors > NEIGHBOR_CAP) break;
                                }
                            }
                            nIdx = next[nIdx];
                        }
                    }
                }

                // --- SETTLING FORWARD LOCK ---
                const dot = steerX * lookX + steerY * lookY;
                // Allow a small amount of backward movement to let the pack "settle"
                // but keep it primarily forward-facing.
                const backwardLimit = -2;
                if (dot < backwardLimit) {
                    steerX -= lookX * (dot - backwardLimit);
                    steerY -= lookY * (dot - backwardLimit);
                }

                const mag = Math.sqrt(steerX * steerX + steerY * steerY);
                if (mag > 0.1) {
                    const speed = Math.min(data[idx + 6] * 2, mag * 20);
                    const moveAngle = Math.atan2(steerY, steerX);
                    data[idx] += Math.cos(moveAngle) * speed;
                    data[idx + 1] += Math.sin(moveAngle) * speed;
                    data[idx + 7] = look;
                    data[idx + 4] = look + cfg.baseRotation;
                    data[idx + 5] = (mag > 0.3) ? (data[idx + 5] + speed * cfg.walkAnimSpeed) % cfg.walkFrames : 0;
                } else {
                    data[idx + 5] = 0;
                    if (d < cfg.attackRange * 1.5) { data[idx + 7] = look; data[idx + 4] = look + cfg.baseRotation; }
                }

                // --- ATTACK LOGIC ---
                if (d < cfg.attackRange && data[idx + 8] > 0) {
                    if (data[idx + 10] === 0) data[idx + 10] = 0.1;
                    else {
                        const prevF = Math.floor(data[idx + 10]);
                        data[idx + 10] += cfg.attackAnimSpeed;
                        const currF = Math.floor(data[idx + 10]);
                        if (prevF < (cfg.attackFrames / 2) && currF >= (cfg.attackFrames / 2)) {
                            player.health -= cfg.damageMin + Math.random() * (cfg.damageMax - cfg.damageMin);
                            if (player.health < 0) {
                                player.health = 0;
                                setTimeout(softReset, 1000);
                            }
                        }
                        if (data[idx + 10] >= cfg.attackFrames) data[idx + 10] = 0.1;
                    }
                } else { data[idx + 10] = 0; }
            }

            // Update UI
            document.getElementById('player-health-bar').style.width = (player.health / PLAYER_HEALTH_MAX * 100) + '%';

            // Update Damage Numbers
            for (let i = damageNumbers.length - 1; i >= 0; i--) {
                const dn = damageNumbers[i];
                dn.x += dn.vx; dn.y += dn.vy; dn.life -= 0.02;
                if (dn.life <= 0) damageNumbers.splice(i, 1);
            }

            document.getElementById('kills').innerText = `Kills: ${killCount}`;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Sync CSS Background for Zero-Cost Tile Overheads
            if (floorPattern) {
                const bgSize = 18144 * zoom; // 6x base tile size (1024 * 6)
                const bgX = -player.x * zoom + (canvas.width / 2);
                const bgY = -player.y * zoom + (canvas.height / 2);
                document.body.style.backgroundPosition = `${bgX}px ${bgY}px`;
                document.body.style.backgroundSize = `${bgSize}px`;
            }

            const cx = canvas.width / 2, cy = canvas.height / 2;
            ctx.save();
            ctx.translate(cx, cy);
            ctx.scale(zoom, zoom);
            ctx.translate(-player.x, -player.y);

            // Culling bounds (+100px margin)
            const margin = 100 + (Math.max(Enemy.Tiyger.size, Enemy.GalaxyDragon.size) / 2);
            const left = player.x - (cx / zoom) - margin;
            const right = player.x + (cx / zoom) + margin;
            const top = player.y - (cy / zoom) - margin;
            const bottom = player.y + (cy / zoom) + margin;

            // Background Tile Texture (Handled by CSS)

            // Dynamic Smoothing Loop
            smoothedEnemies += (onScreenCount - smoothedEnemies) * 0.15;
            let activeTierIdx = PERFORMANCE.LOD_TIERS.length - 1;
            for (let i = 0; i < PERFORMANCE.LOD_TIERS.length; i++) {
                if (smoothedEnemies <= PERFORMANCE.LOD_TIERS[i].max) {
                    activeTierIdx = i; break;
                }
            }
            const activeTierID = PERFORMANCE.LOD_TIERS[activeTierIdx].id;

            // Update Map Pointers (Lazy update only when needed)
            if (!this.cachedReadyMap || readyMapDirty) {
                this.cachedReadyMap = {
                    Tiyger: { walk: [], death: [], attack: [] },
                    GalaxyDragon: { walk: [], death: [], attack: [] }
                };
                for (const type of ["Tiyger", "GalaxyDragon"]) {
                    const cache = enemyAssets[type].caches;
                    ["walk", "death", "attack"].forEach(anim => {
                        this.cachedReadyMap[type][anim] = PERFORMANCE.LOD_TIERS.map(t => ({ id: t.id, frames: cache[anim][t.id] }));
                    });
                }
                readyMapDirty = false;
            }

            // High-Speed Direct Draw
            const readyMap = this.cachedReadyMap;
            const gridOffset = (GRID_DIM * GRID_CELL) / 2;
            const gxMin = Math.max(0, Math.floor((left - player.x + gridOffset) / GRID_CELL)), gxMax = Math.min(GRID_DIM - 1, Math.floor((right - player.x + gridOffset) / GRID_CELL));
            const gyMin = Math.max(0, Math.floor((top - player.y + gridOffset) / GRID_CELL)), gyMax = Math.min(GRID_DIM - 1, Math.floor((bottom - player.y + gridOffset) / GRID_CELL));

            onScreenCount = 0;
            for (let gy = gyMin; gy <= gyMax; gy++) {
                for (let gx = gxMin; gx <= gxMax; gx++) {
                    let ptr = heads[gy * GRID_DIM + gx];
                    while (ptr !== -1) {
                        const idx = ptr * stride;
                        const x = data[idx], y = data[idx + 1];
                        if (x > left && x < right && y > top && y < bottom) {
                            const h = data[idx + 8], df = data[idx + 9];
                            if (h > 0 || df > 0) {
                                onScreenCount++;
                                const f = Math.floor(data[idx + 5]), rot = data[idx + 4], look = data[idx + 7], af = Math.floor(data[idx + 10]);
                                const typeKey = data[idx + 11] === 0 ? "Tiyger" : "GalaxyDragon";
                                const cfg = Enemy[typeKey], assets = enemyAssets[typeKey];

                                const animType = (h <= 0 && df > 0) ? 'death' : (af > 0 ? 'attack' : 'walk');
                                const frameIdx = (h <= 0 && df > 0) ? df : (af > 0 ? af : f);
                                const tiers = readyMap[typeKey][animType];

                                let frameToDraw = null;
                                if (tiers[activeTierIdx].frames && tiers[activeTierIdx].frames[frameIdx]) {
                                    frameToDraw = tiers[activeTierIdx].frames[frameIdx];
                                } else {
                                    let offset = 1;
                                    while (activeTierIdx - offset >= 0 || activeTierIdx + offset < tiers.length) {
                                        const up = activeTierIdx - offset;
                                        if (up >= 0 && tiers[up].frames && tiers[up].frames[frameIdx]) {
                                            frameToDraw = tiers[up].frames[frameIdx]; break;
                                        }
                                        const down = activeTierIdx + offset;
                                        if (down < tiers.length && tiers[down].frames && tiers[down].frames[frameIdx]) {
                                            frameToDraw = tiers[down].frames[frameIdx]; break;
                                        }
                                        offset++;
                                    }
                                }

                                ctx.save();
                                ctx.translate(x, y);
                                ctx.rotate(rot);
                                if (cfg.isSideways && Math.abs(look) < Math.PI / 2) ctx.scale(1, -1);
                                if (h <= 0 && df > 0) ctx.globalAlpha = Math.max(0, 1 - (df / cfg.deathFrames - 0.7) * 3);

                                if (frameToDraw) ctx.drawImage(frameToDraw, -cfg.size / 2, -cfg.size / 2, cfg.size, cfg.size);
                                else {
                                    const sheet = assets[animType];
                                    const sCols = cfg[animType + 'Cols'], sSize = cfg[animType + 'Size'];
                                    ctx.drawImage(sheet, (frameIdx % sCols) * sSize, Math.floor(frameIdx / sCols) * sSize, sSize, sSize, -cfg.size / 2, -cfg.size / 2, cfg.size, cfg.size);
                                }
                                ctx.restore();
                            }
                        }
                        ptr = next[ptr];
                    }
                }
            }

            // Player Visual
            ctx.setTransform(zoom, 0, 0, zoom, cx, cy);
            ctx.beginPath(); ctx.arc(0, 0, 80, 0, Math.PI * 2);
            ctx.fillStyle = "#0ff"; ctx.shadowColor = "#0ff"; ctx.shadowBlur = 40; ctx.fill();
            ctx.shadowBlur = 0;

            // Damage Numbers
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.font = "bold 24px Arial";
            for (const dn of damageNumbers) {
                const sx = (dn.x - player.x) * zoom + cx;
                const sy = (dn.y - player.y) * zoom + cy;
                ctx.fillStyle = `rgba(255, 0, 0, ${dn.life})`;
                ctx.fillText(dn.val, sx, sy);
            }
            ctx.restore();
        }

        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
        window.addEventListener('wheel', (e) => { targetZoom *= e.deltaY > 0 ? 0.9 : 1.1; targetZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, targetZoom)); });

        let loadedCt = 0;
        const totalToLoad = 7;
        function onAssetLoad() {
            loadedCt++;
            if (loadedCt === totalToLoad) {
                document.body.style.backgroundImage = `url("${FLOOR_PATH}")`;
                floorPattern = true;
                buildEnemyCache("Tiyger");
                buildEnemyCache("GalaxyDragon");
                init(true);
                canvas.width = window.innerWidth; canvas.height = window.innerHeight;
                let last = 0, f = 0, t = 0;
                let physicsTimeSum = 0;
                let drawTimeSum = 0;

                function loop(now) {
                    const dt = now - last; last = now;
                    t += dt; f++;

                    // Sub-stepping logic for ultra-high speed without tunneling
                    const steps = Math.min(10, Math.ceil(PERFORMANCE.GAME_SPEED));
                    const stepDt = dt * (PERFORMANCE.GAME_SPEED / steps);

                    const sUpdate = performance.now();
                    for (let s = 0; s < steps; s++) {
                        update(stepDt, now + (s * stepDt));
                    }
                    physicsTimeSum += (performance.now() - sUpdate);

                    const sDraw = performance.now();
                    draw();
                    drawTimeSum += (performance.now() - sDraw);

                    if (t > 1000) {
                        const avgPhys = (physicsTimeSum / f).toFixed(2);
                        const avgDraw = (drawTimeSum / f).toFixed(2);
                        const msg = `FPS: ${f} | Logic: ${avgPhys}ms | Draw: ${avgDraw}ms | Tasks: ${workerTasksCount}`;
                        document.getElementById('fps').innerText = msg;
                        console.log(`[Perf] ${msg}`);
                        f = 0; t = 0; physicsTimeSum = 0; drawTimeSum = 0;
                    }
                    requestAnimationFrame(loop);
                }
                requestAnimationFrame(loop);
            }
        }

        const load = (path, img) => {
            img.onload = onAssetLoad;
            img.src = path;
        };
        load(Enemy.Tiyger.walkPath, enemyAssets.Tiyger.walk);
        load(Enemy.Tiyger.deathPath, enemyAssets.Tiyger.death);
        load(Enemy.Tiyger.attackPath, enemyAssets.Tiyger.attack);
        load(Enemy.GalaxyDragon.walkPath, enemyAssets.GalaxyDragon.walk);
        load(Enemy.GalaxyDragon.deathPath, enemyAssets.GalaxyDragon.death);
        load(Enemy.GalaxyDragon.attackPath, enemyAssets.GalaxyDragon.attack);
        load(FLOOR_PATH, floorImg);

        // Speed Controller Logic
        const slider = document.getElementById('speed-slider');
        const speedVal = document.getElementById('speed-val');
        slider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            PERFORMANCE.GAME_SPEED = val;
            speedVal.innerText = val.toFixed(1) + 'x';
        });
    </script>
</body>

</html>