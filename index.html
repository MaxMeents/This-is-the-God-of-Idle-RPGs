<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>God of Idle RPGs - Combat Prototype</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #050505;
            color: #fff;
            font-family: 'Segoe UI', sans-serif;
            background-image: none;
            /* Set dynamically */
            background-repeat: repeat;
            background-attachment: fixed;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #ffcc00;
            box-shadow: 0 0 20px rgba(255, 204, 0, 0.3);
            z-index: 100;
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: #ffcc00;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stat {
            font-family: monospace;
            font-size: 14px;
            margin-top: 10px;
            color: #00ff88;
        }

        .controls {
            font-size: 12px;
            margin-top: 15px;
            color: #aaa;
        }

        #hud-bottom-center {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #player-health-container {
            position: relative;
            width: 100%;
            height: 30px;
            background: rgba(255, 255, 255, 0.2);
            border: 4px solid #fff;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
            border-radius: 15px;
            overflow: hidden;
        }

        #player-health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #0096ff, #00d4ff);
            transition: width 0.1s ease-out;
            position: relative;
            z-index: 1;
        }

        #player-shield-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffcc00);
            z-index: 2;
            transition: width 0.1s ease-out;
            box-shadow: 0 0 15px #ffd700;
        }

        #shield-charge-container {
            width: 100%;
            height: 10px;
            background: #000;
            border: 2px solid #000;
            border-radius: 5px;
            box-sizing: border-box;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        #shield-charge-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffcc00);
            box-shadow: 0 0 8px #ffd700;
            transition: width 0.1s ease-out;
        }

        #speed-ctrl-container {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.2);
            z-index: 100;
            pointer-events: auto;
            width: 200px;
        }

        .speed-label {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #00ff88;
            margin-bottom: 8px;
            font-weight: bold;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
            accent-color: #00ff88;
        }

        #skill-button-container {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 140px;
            height: 140px;
            cursor: pointer;
            z-index: 2000;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #skill-button-canvas {
            width: 100%;
            height: 100%;
        }

        #skill-timer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 80px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.8), 0 0 10px #ffcc00;
            pointer-events: none;
            display: none;
            line-height: 1;
        }
    </style>
</head>

<body>
    <div id="loading">Initializing Combat Engine...</div>
    <div id="ui">
        <h1>GOD OF IDLE RPGs</h1>
        <div id="count" class="stat">Tigers: 300</div>
        <div id="kills" class="stat">Kills: 0</div>
        <div id="fps" class="stat">FPS: 0</div>
        <div class="controls">
            [SCROLL] Zoom Camera<br>
            Player ball automatically hunts nearest tiger.<br>
            Screen follows player.
        </div>
    </div>
    <div id="speed-ctrl-container">
        <div class="speed-label">
            <span>GAME SPEED</span>
            <span id="speed-val">1.0x</span>
        </div>
        <input type="range" id="speed-slider" min="1" max="20" step="1" value="1">
    </div>
    <div id="hud-bottom-center">
        <div id="shield-charge-container">
            <div id="shield-charge-bar"></div>
        </div>
        <div id="player-health-container">
            <div id="player-health-bar"></div>
            <div id="player-shield-bar"></div>
        </div>
    </div>
    <div id="skill-button-container">
        <canvas id="skill-button-canvas" width="256" height="256"></canvas>
        <div id="skill-timer">0</div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        /**
         * God of Idle RPGs - Combat Engine Prototype
         * Focus: Automated Combat, Floating Damage Numbers, Optimized Data.
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: true });

        // CONFIG
        const Enemy = {
            Tiyger: {
                count: 0, // Default lower for broad compatibility, but scales to 10k
                size: 2500,
                healthMax: 35,
                moveSpeed: 15,
                spacing: 120,
                closestDist: 400,
                startDist: 10000,
                attackRange: 1500,
                damageMin: 25,
                damageMax: 100,
                walkPath: 'img/Figer Walking/Spritesheet/1024x1024/grok-video-c940ad13-8ea0-454d-8b91-76e181b1f208 (10)_1024x1024_sheet.png',
                deathPath: 'img/Figer Death/Spritesheet/512x512/Figer Death_512x512_sheet.png',
                attackPath: 'img/Fiyger Forward Attack/Spritesheet/512x512/Fiyger Forward Attack_512x512_sheet.png',
                walkFrames: 52, deathFrames: 145, attackFrames: 77,
                walkCols: 8, deathCols: 13, attackCols: 9,
                walkSize: 1024, deathSize: 512, attackSize: 512,
                walkAnimSpeed: 0.04, attackAnimSpeed: 4.0, deathAnimSpeed: 1.5,
                baseRotation: Math.PI, // Facing Right (PI rotation from Left base)
                isSideways: true
            },
            GalaxyDragon: {
                count: 2000,
                size: 3200,
                healthMax: 50,
                moveSpeed: 12,
                spacing: 200,
                closestDist: 600,
                startDist: 12000,
                attackRange: 2000,
                damageMin: 10,
                damageMax: 30,
                walkPath: 'img/Enemies/Galaxy Dragon/Galaxy Dragon Flying Forward/Spritesheet/512x512/Galaxy Dragon Flying Forward_512x512_sheet.png',
                deathPath: 'img/Enemies/Galaxy Dragon/Galaxy Dragon Death/Spritesheet/512x512/Galaxy Dragon Death_512x512_sheet.png',
                attackPath: 'img/Enemies/Galaxy Dragon/Galaxy Dragon Attack/Spritesheet/512x512/Galaxy Dragon Attack_512x512_sheet.png',
                walkFrames: 53, deathFrames: 145, attackFrames: 13,
                walkCols: 8, deathCols: 13, attackCols: 4,
                walkSize: 512, deathSize: 512, attackSize: 512, // Correct frame size from metadata
                walkAnimSpeed: 0.02, attackAnimSpeed: 1.0, deathAnimSpeed: 1.5,
                baseRotation: Math.PI / 2, // Facing North (Up)
                isSideways: false
            }
        };

        const enemyKeys = Object.keys(Enemy);
        const totalEnemies = enemyKeys.reduce((sum, key) => sum + Enemy[key].count, 0);
        const DAMAGE_PER_POP = 10;
        const DAMAGE_INTERVAL = 100; // ms
        const AOE_RADIUS = 900;
        const PLAYER_SPEED = 20;
        const FLOOR_PATH = 'img/Texture Floor/maxmaxmax_333_Ocean_temple_floor_tile_design_wave_patterns_biol_31b2bdc2-1580-4081-86b9-2f7b711e9005_1.png';
        const PLAYER_HEALTH_MAX = 35000;
        const MIN_ZOOM = 0.0001;
        const MAX_ZOOM = 2590.0;

        const PERFORMANCE = {
            // LOD Tiers sorted from Highest to Lowest quality
            LOD_TIERS: [
                { id: 'Ultra', size: 1024, max: 15 },
                { id: 'High', size: 1024, max: 40 },
                { id: 'MidHigh', size: 768, max: 70 },
                { id: 'Med', size: 512, max: 120 },
                { id: 'MedLow', size: 256, max: 250 },
                { id: 'Low', size: 128, max: 500 },
                { id: 'VLow', size: 64, max: 1000 },
                { id: 'Tiny', size: 32, max: 2000 },
                { id: 'Micro', size: 16, max: 9999 }
            ],
            LOD_INIT_TIME_SLICE: 1, // ms per frame
            SPAWNS_PER_FRAME: 50,
            GAME_SPEED: 1.0 // Can be set up to 20.0
        };

        const SHIP_CONFIG = {
            onPath: 'img/Ship/Ship Engines on/Spritesheet/768x768/Ship Engines on_768x768_sheet.png',
            fullPath: 'img/Ship/Ship Full Engine Power/Spritesheet/768x768/Ship Full Engine Power_768x768_sheet.png',
            onFrames: 27, onCols: 6, onSize: 768,
            fullFrames: 18, fullCols: 5, fullSize: 768,

            idleFrames: 3, // Frames to loop when "at" destination
            animSpeed: 0.5,
            fullPowerDist: 8000,
            thrustDist: 1500, // Engines kick in at this distance
            reachDist: 200,
            visualSize: 800,
            stopRange: 10,
            turnSpeed: Math.PI * 3, // Rads per sec (180 deg in 1/3 sec)

            // Shield Settings
            shieldOnPath: 'img/Ship/Ship Shield Is On/Spritesheet/1024x1024/Ship Shield Is On_1024x1024_sheet.png',
            shieldTurnOnPath: 'img/Ship/Ship Shield Turn On/Spritesheet/768x768/Ship Shield Turn On_768x768_sheet.png',
            shieldOnFrames: 14, shieldOnCols: 4, shieldOnSize: 1024,
            shieldTurnOnFrames: 145, shieldTurnOnCols: 13, shieldTurnOnSize: 768,

            shieldMaxHealthMult: 3,
            shieldDuration: 10000, // 10s
            shieldCooldown: 15000,  // 15s
            shieldVisualSize: 1200
        };

        const shipAssets = {
            onImg: new Image(),
            fullImg: new Image(),
            shieldOnImg: new Image(),
            shieldTurnOnImg: new Image(),
            onCache: [],
            fullCache: [],
            shieldOnCache: [],
            shieldTurnOnCache: [],
            baked: false
        };

        const SKILLS = {
            MulticolorXFlame: {
                buttonSheet: 'img/Skills/Buttons/Multicolor X Flame Button/Spritesheet/768x768/Multicolor X Flame Button_768x768_sheet.png',
                skillSheet: 'img/Skills/Multicolor X Flame/Spritesheet/512x512/Multicolor X Flame_512x512_sheet.png',
                buttonFrames: 121, buttonCols: 11, buttonSize: 768,
                skillFrames: 109, skillCols: 11, skillSize: 512,

                // ADJUSTABLE SETTINGS
                animSpeedButton: 0.9,
                animSpeedSkill: 2,
                cooldownTime: 2000,
                instanceCount: 12,
                damageMult: 30.0,
                aoeMult: 1.25,
                visualSize: 1800,
                orbitRadius: 1500
            }
        };

        const skillAssets = {
            buttonImg: new Image(),
            skillImg: new Image(),
            buttonCache: [],
            skillCache: [],
            ready: false,
            baked: false
        };

        const activeSkills = [];
        let skillCooldownRemaining = 0;
        let skillBtnFrame = 0;
        const skillBtnCanvas = document.getElementById('skill-button-canvas');
        const skillBtnCtx = skillBtnCanvas.getContext('2d');

        let zoom = 0.35;
        let targetZoom = 0.35;
        const player = {
            x: 0, y: 0,
            targetIdx: -1,
            lastDamageTime: 0,
            health: PLAYER_HEALTH_MAX,
            shipFrame: 0,
            shipState: 'IDLE', // IDLE, THRUST, FULL, REVERSE
            rotation: 0,

            // Shield state
            shieldHP: 0,
            shieldMaxHP: PLAYER_HEALTH_MAX * SHIP_CONFIG.shieldMaxHealthMult,
            shieldActive: false,
            shieldCooldownRemaining: 0,
            shieldDurationRemaining: 0,
            shieldAnimState: 'OFF', // OFF, TURNING_ON, ON
            shieldFrame: 0
        };
        let killCount = 0;
        let smoothedEnemies = 0;
        let onScreenCount = 0;
        let spawnIndex = 0;
        const spawnList = [];

        // Data: [x, y, vx, vy, rot, frame, speed, look, health, deathFrame, attackFrame, typeIndex]
        const stride = 12;
        const data = new Float32Array(totalEnemies * stride);

        // Floating Numbers Pooled
        const damageNumbers = []; // {x, y, val, life}

        // Spatial Grid
        const GRID_CELL = 4800;
        const GRID_DIM = 400;
        const heads = new Int32Array(GRID_DIM * GRID_DIM).fill(-1);
        const next = new Int32Array(totalEnemies);
        const occupiedCells = new Int32Array(GRID_DIM * GRID_DIM); // Track which cells to clear
        let occupiedCount = 0;

        // Dynamic Asset Mapping
        const enemyAssets = {};
        enemyKeys.forEach(k => {
            enemyAssets[k] = {
                walk: new Image(),
                death: new Image(),
                attack: new Image(),
                caches: { walk: {}, death: {}, attack: {} }
            };
        });

        const floorImg = new Image();
        let floorPattern = null;

        function spawnEnemy(i, typeKey, far = false) {
            const cfg = Enemy[typeKey];
            const idx = i * stride;
            const angle = Math.random() * Math.PI * 2;
            const distBase = cfg.startDist + (Math.random() * cfg.startDist * 0.5);
            const dist = far ? distBase * 1.5 : distBase;

            data[idx] = player.x + Math.cos(angle) * dist;
            data[idx + 1] = player.y + Math.sin(angle) * dist;
            data[idx + 6] = cfg.moveSpeed * (0.8 + Math.random() * 0.4);
            data[idx + 8] = cfg.healthMax;
            data[idx + 9] = 0;
            data[idx + 5] = Math.random() * cfg.walkFrames;
            data[idx + 10] = 0;
            data[idx + 11] = enemyKeys.indexOf(typeKey);
        }

        function init(firstLoad = false) {
            player.health = PLAYER_HEALTH_MAX;
            player.x = 0; player.y = 0;
            killCount = 0;
            damageNumbers.length = 0;
            activeSkills.length = 0;
            skillCooldownRemaining = 0;

            // Shield Reset
            player.shieldMaxHP = PLAYER_HEALTH_MAX * SHIP_CONFIG.shieldMaxHealthMult;
            player.shieldHP = player.shieldMaxHP;
            player.shieldActive = false;
            player.shieldCooldownRemaining = 0;
            player.shieldDurationRemaining = 0;
            player.shieldAnimState = 'OFF';
            player.shieldFrame = 0;

            data.fill(0);
            spawnIndex = 0;

            if (firstLoad || spawnList.length === 0) {
                spawnList.length = 0;
                for (let i = 0; i < Enemy.Tiyger.count; i++) spawnList.push("Tiyger");
                for (let i = 0; i < Enemy.GalaxyDragon.count; i++) spawnList.push("GalaxyDragon");
            }

            if (firstLoad) document.getElementById('loading').style.display = 'none';
        }

        function softReset() {
            init(false);
        }

        // Global Cache Manager
        // Hybrid Cache Manager: Uses Worker if possible, or a non-blocking Main Thread loop otherwise.
        let workerTasksCount = 0;
        let isWorkerSafe = false;

        const bakerWorker = (() => {
            // file:// protocol blocks ImageBitmap cloning for security. 
            // Disable worker for local files to avoid DataCloneError.
            if (window.location.protocol === 'file:') return null;

            try {
                const blob = new Blob([`
                    self.onmessage = async (e) => {
                        const { typeKey, animType, sheet, tier, frameCount, cols, sourceSize } = e.data;
                        const results = [];
                        const size = tier.size;
                        for (let i = 0; i < frameCount; i++) {
                            const canvas = new OffscreenCanvas(size, size);
                            const ctx = canvas.getContext('2d');
                            ctx.imageSmoothingEnabled = true;
                            ctx.drawImage(sheet, (i % cols) * sourceSize, Math.floor(i / cols) * sourceSize, sourceSize, sourceSize, 0, 0, size, size);
                            results.push(canvas.transferToImageBitmap());
                        }
                        self.postMessage({ typeKey, animType, tierID: tier.id, results }, results);
                    };
                `], { type: 'application/javascript' });
                const w = new Worker(URL.createObjectURL(blob));
                isWorkerSafe = true;
                return w;
            } catch (e) {
                console.warn("[Baker] Worker disabled.");
                return null;
            }
        })();

        if (bakerWorker) {
            bakerWorker.onmessage = (e) => {
                const { typeKey, animType, tierID, results } = e.data;
                enemyAssets[typeKey].caches[animType][tierID] = results;
                workerTasksCount--;
            };
        }

        const fallbackQueue = [];
        let isFallbackRunning = false;
        const bakedStatus = {};
        const inQueue = new Set();

        function runFallbackBaker() {
            if (fallbackQueue.length === 0) { isFallbackRunning = false; return; }
            isFallbackRunning = true;

            // Only sort when a new high-priority request comes in, not every tick
            if (needsSort) {
                fallbackQueue.sort((a, b) => {
                    const aNeeded = (a.typeKey === lastRequestedType && a.tier.id === lastRequestedTier) ? 0 : 1;
                    const bNeeded = (b.typeKey === lastRequestedType && b.tier.id === lastRequestedTier) ? 0 : 1;
                    return aNeeded - bNeeded || a.tier.size - b.tier.size;
                });
                needsSort = false;
            }

            const startTime = performance.now();
            while (fallbackQueue.length > 0 && (performance.now() - startTime < 2)) {
                const task = fallbackQueue[0];
                const assets = enemyAssets[task.typeKey];
                if (!assets.caches[task.animType][task.tier.id]) assets.caches[task.animType][task.tier.id] = [];

                const i = task.currentFrame;
                const canvas = document.createElement('canvas');
                canvas.width = task.tier.size; canvas.height = task.tier.size;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.drawImage(assets[task.animType], (i % task.cols) * task.sourceSize, Math.floor(i / task.cols) * task.sourceSize, task.sourceSize, task.sourceSize, 0, 0, task.tier.size, task.tier.size);

                assets.caches[task.animType][task.tier.id][i] = canvas;
                task.currentFrame++;

                if (task.currentFrame >= task.frameCount) {
                    if (!bakedStatus[task.typeKey]) bakedStatus[task.typeKey] = {};
                    if (!bakedStatus[task.typeKey][task.animType]) bakedStatus[task.typeKey][task.animType] = {};
                    bakedStatus[task.typeKey][task.animType][task.tier.id] = true;

                    inQueue.delete(`${task.typeKey}:${task.animType}:${task.tier.id}`);
                    fallbackQueue.shift();
                    workerTasksCount--;
                    readyMapDirty = true; // Signal the draw loop to update its pointers
                }
            }
            if (fallbackQueue.length > 0) setTimeout(runFallbackBaker, 10);
            else isFallbackRunning = false;
        }

        let lastRequestedType = null;
        let lastRequestedTier = null;
        let needsSort = false;
        let readyMapDirty = true;

        async function buildEnemyCache(typeKey, fullBake = false) {
            const cfg = Enemy[typeKey];
            const tiersToQueue = fullBake ? PERFORMANCE.LOD_TIERS : PERFORMANCE.LOD_TIERS.filter(t => t.size <= 128);

            for (let tier of tiersToQueue) {
                ['walk', 'death', 'attack'].forEach(anim => {
                    const key = `${typeKey}:${anim}:${tier.id}`;
                    if (bakedStatus[typeKey]?.[anim]?.[tier.id] || inQueue.has(key)) return;

                    workerTasksCount++;
                    inQueue.add(key);
                    fallbackQueue.push({ typeKey, animType: anim, tier, frameCount: cfg[anim + 'Frames'], cols: cfg[anim + 'Cols'], sourceSize: cfg[anim + 'Size'], currentFrame: 0 });
                });
            }
            needsSort = true;
            if (!isFallbackRunning) runFallbackBaker();
        }

        function ensureTierBaking(typeKey, tierID) {
            if (lastRequestedType === typeKey && lastRequestedTier === tierID) return;
            const tier = PERFORMANCE.LOD_TIERS.find(t => t.id === tierID);
            if (!tier) return;

            lastRequestedType = typeKey;
            lastRequestedTier = tierID;
            needsSort = true;

            const cfg = Enemy[typeKey];
            ['walk', 'death', 'attack'].forEach(anim => {
                const key = `${typeKey}:${anim}:${tier.id}`;
                if (bakedStatus[typeKey]?.[anim]?.[tier.id] || inQueue.has(key)) return;

                workerTasksCount++;
                inQueue.add(key);
                fallbackQueue.push({ typeKey, animType: anim, tier, frameCount: cfg[anim + 'Frames'], cols: cfg[anim + 'Cols'], sourceSize: cfg[anim + 'Size'], currentFrame: 0 });
            });
            if (!isFallbackRunning) runFallbackBaker();
        }

        function triggerSkill() {
            const cfg = SKILLS.MulticolorXFlame;
            if (skillCooldownRemaining > 0) return;

            skillCooldownRemaining = cfg.cooldownTime;

            for (let i = 0; i < cfg.instanceCount; i++) {
                const angle = (i / cfg.instanceCount) * Math.PI * 2;
                activeSkills.push({
                    angle: angle,
                    frame: 0,
                    done: false
                });
            }
        }

        function update(dt, now) {
            if (player.health <= 0) return;
            const sc = SHIP_CONFIG;

            // --- SHIELD UPDATE ---
            if (player.shieldActive) {
                player.shieldDurationRemaining -= dt * PERFORMANCE.GAME_SPEED;

                if (player.shieldAnimState === 'TURNING_ON') {
                    player.shieldFrame += 1.5 * (dt / 16.6) * PERFORMANCE.GAME_SPEED;
                    if (player.shieldFrame >= sc.shieldTurnOnFrames) {
                        player.shieldAnimState = 'ON';
                        player.shieldFrame = 0;
                    }
                } else if (player.shieldAnimState === 'ON') {
                    player.shieldFrame = (player.shieldFrame + 0.4 * (dt / 16.6) * PERFORMANCE.GAME_SPEED) % sc.shieldOnFrames;
                }

                if (player.shieldDurationRemaining <= 0 || player.shieldHP <= 0) {
                    player.shieldActive = false;
                    player.shieldAnimState = 'OFF';
                    player.shieldCooldownRemaining = sc.shieldCooldown;
                }
            } else {
                if (player.shieldCooldownRemaining > 0) {
                    player.shieldCooldownRemaining -= dt * PERFORMANCE.GAME_SPEED;
                    if (player.shieldCooldownRemaining < 0) player.shieldCooldownRemaining = 0;
                }
            }

            // Sync Shield UI
            const shieldBar = document.getElementById('player-shield-bar');
            const chargeBar = document.getElementById('shield-charge-bar');
            if (player.shieldActive) {
                shieldBar.style.width = (player.shieldHP / player.shieldMaxHP * 100) + '%';
            } else {
                shieldBar.style.width = '0%';
            }
            chargeBar.style.width = ((sc.shieldCooldown - player.shieldCooldownRemaining) / sc.shieldCooldown * 100) + '%';

            for (let i = 0; i < PERFORMANCE.SPAWNS_PER_FRAME && spawnIndex < totalEnemies; i++) {
                spawnEnemy(spawnIndex, spawnList[spawnIndex], true);
                spawnIndex++;
            }

            zoom += (targetZoom - zoom) * 0.1;

            // 1. CLEAR AND REBUILD GRID FIRST (Used for Physics AND Targeting)
            const gridOffset = (GRID_DIM * GRID_CELL) / 2;
            for (let i = 0; i < occupiedCount; i++) heads[occupiedCells[i]] = -1;
            occupiedCount = 0;

            for (let i = 0; i < spawnIndex; i++) {
                const idx = i * stride;
                if (data[idx + 8] <= 0) continue;
                const gx = Math.floor((data[idx] - player.x + gridOffset) / GRID_CELL);
                const gy = Math.floor((data[idx + 1] - player.y + gridOffset) / GRID_CELL);
                const cIdx = gy * GRID_DIM + gx;
                if (cIdx >= 0 && cIdx < heads.length) {
                    if (heads[cIdx] === -1) occupiedCells[occupiedCount++] = cIdx;
                    next[i] = heads[cIdx];
                    heads[cIdx] = i;
                }
            }

            // 2. Spatial Nearest Finding (Only every few steps or every frame for performance)
            if (now - (player.lastTargetTime || 0) > 100) {
                player.lastTargetTime = now;
                let closestDist = Infinity;
                let found = -1;
                const searchRadius = 2; // Cells
                const pgx = Math.floor(gridOffset / GRID_CELL);
                const pgy = Math.floor(gridOffset / GRID_CELL);

                for (let ox = -searchRadius; ox <= searchRadius; ox++) {
                    for (let oy = -searchRadius; oy <= searchRadius; oy++) {
                        let ptr = heads[(pgy + oy) * GRID_DIM + (pgx + ox)];
                        while (ptr !== -1) {
                            const idx = ptr * stride;
                            const dx = data[idx] - player.x, dy = data[idx + 1] - player.y;
                            const dSq = dx * dx + dy * dy;
                            if (dSq < closestDist) { closestDist = dSq; found = ptr; }
                            ptr = next[ptr];
                        }
                    }
                }
                player.targetIdx = found;
            }

            // 3. Movement and AOE Logic
            if (player.targetIdx !== -1) {
                const sc = SHIP_CONFIG;
                const tIdx = player.targetIdx * stride;
                const dx = data[tIdx] - player.x;
                const dy = data[tIdx + 1] - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                const targetRot = Math.atan2(dy, dx);
                let diff = targetRot - player.rotation;
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;

                const step = sc.turnSpeed * (dt / 1000) * PERFORMANCE.GAME_SPEED;
                if (Math.abs(diff) < step) player.rotation = targetRot;
                else player.rotation += Math.sign(diff) * step;

                if (dist > 10) {
                    player.x += (dx / dist) * PLAYER_SPEED;
                    player.y += (dy / dist) * PLAYER_SPEED;
                }

                // --- SHIP ANIMATION LOGIC ---
                const spd = sc.animSpeed * (dt / 16.6) * PERFORMANCE.GAME_SPEED;

                if (dist > sc.fullPowerDist) {
                    player.shipState = 'FULL';
                    player.shipFrame = (player.shipFrame + spd) % sc.fullFrames;
                } else if (dist > sc.thrustDist) {
                    player.shipState = 'THRUST';
                    player.shipFrame = (player.shipFrame + spd) % sc.onFrames;
                } else if (dist > sc.reachDist) {
                    // COASTING - Moving but engines not "on"
                    if (player.shipState === 'FULL' || player.shipState === 'THRUST' || player.shipState === 'REVERSE') {
                        if (player.shipState !== 'REVERSE') {
                            player.shipState = 'REVERSE';
                            player.shipFrame = Math.min(sc.stopRange, player.shipFrame);
                        }
                        player.shipFrame -= spd * 2;
                        if (player.shipFrame <= sc.idleFrames) {
                            player.shipFrame = 0;
                            player.shipState = 'IDLE';
                        }
                    } else {
                        player.shipState = 'IDLE';
                        player.shipFrame = (player.shipFrame + spd) % sc.idleFrames;
                    }
                } else {
                    // REACHED 
                    if (player.shipState === 'FULL' || player.shipState === 'THRUST' || player.shipState === 'REVERSE') {
                        if (player.shipState !== 'REVERSE') {
                            player.shipState = 'REVERSE';
                            player.shipFrame = Math.min(sc.stopRange, player.shipFrame);
                        }
                        player.shipFrame -= spd * 2;
                        if (player.shipFrame <= sc.idleFrames) {
                            player.shipFrame = 0;
                            player.shipState = 'IDLE';
                        }
                    } else {
                        player.shipState = 'IDLE';
                        player.shipFrame = (player.shipFrame + spd) % sc.idleFrames;
                    }
                }

                if (now - player.lastDamageTime > DAMAGE_INTERVAL) {
                    player.lastDamageTime = now;
                    const rSq = AOE_RADIUS * AOE_RADIUS;
                    const pgx = Math.floor(gridOffset / GRID_CELL);
                    const pgy = Math.floor(gridOffset / GRID_CELL);
                    const rCell = Math.ceil(AOE_RADIUS / GRID_CELL);

                    for (let ox = -rCell; ox <= rCell; ox++) {
                        for (let oy = -rCell; oy <= rCell; oy++) {
                            let ptr = heads[(pgy + oy) * GRID_DIM + (pgx + ox)];
                            while (ptr !== -1) {
                                const idx = ptr * stride;
                                if (data[idx + 8] <= 0) { ptr = next[ptr]; continue; }
                                const ddx = data[idx] - player.x, ddy = data[idx + 1] - player.y;
                                if (ddx * ddx + ddy * ddy < rSq) {
                                    data[idx + 8] -= DAMAGE_PER_POP;

                                    if (damageNumbers.length < 100) {
                                        damageNumbers.push({ x: data[idx], y: data[idx + 1] - 50, val: DAMAGE_PER_POP, life: 1.0, vx: (Math.random() - 0.5) * 2, vy: -2 - Math.random() * 2 });
                                    }

                                    if (data[idx + 8] <= 0) { killCount++; data[idx + 8] = 0; data[idx + 9] = 1; }
                                }
                                ptr = next[ptr];
                            }
                        }
                    }
                }
            }

            for (let i = 0; i < spawnIndex; i++) {
                const idx = i * stride;
                const typeKey = enemyKeys[data[idx + 11] | 0];
                const cfg = Enemy[typeKey];

                if (data[idx + 8] <= 0) {
                    if (data[idx + 9] > 0) {
                        data[idx + 9] += cfg.deathAnimSpeed;
                        if (data[idx + 9] >= cfg.deathFrames) spawnEnemy(i, typeKey, true);
                    }
                    continue;
                }

                const px = data[idx], py = data[idx + 1];
                const dx = player.x - px, dy = player.y - py;
                const d = Math.sqrt(dx * dx + dy * dy);
                const look = Math.atan2(dy, dx);
                const lookX = Math.cos(look), lookY = Math.sin(look);

                const targetRadius = cfg.closestDist;
                const pSpace = cfg.size + cfg.spacing;
                const pSpaceSq = pSpace * pSpace;

                const distToTarget = Math.abs(d - targetRadius);
                const pullDir = d > targetRadius ? 1 : -0.5;
                let steerX = lookX * distToTarget * 0.5 * pullDir;
                let steerY = lookY * distToTarget * 0.5 * pullDir;

                const gx = Math.floor((px - player.x + gridOffset) / GRID_CELL);
                const gy = Math.floor((py - player.y + gridOffset) / GRID_CELL);
                let neighbors = 0;
                const NEIGHBOR_CAP = 8; // Tighter cap for 10k enemies

                for (let ox = -1; ox <= 1; ox++) {
                    for (let oy = -1; oy <= 1; oy++) {
                        if (neighbors > NEIGHBOR_CAP) break;
                        const cell = (gy + oy) * GRID_DIM + (gx + ox);
                        if (cell < 0 || cell >= heads.length) continue;
                        let nIdx = heads[cell];
                        while (nIdx !== -1) {
                            if (nIdx !== i) {
                                const oIdx = nIdx * stride;
                                const vx = px - data[oIdx], vy = py - data[oIdx + 1];
                                const dSq = vx * vx + vy * vy;
                                if (dSq < pSpaceSq && dSq > 0) {
                                    const dist = Math.sqrt(dSq);
                                    const force = ((pSpace - dist) / pSpace) * 40;
                                    steerX += (vx / dist) * force;
                                    steerY += (vy / dist) * force;
                                    neighbors++;
                                    if (neighbors > NEIGHBOR_CAP) break;
                                }
                            }
                            nIdx = next[nIdx];
                        }
                    }
                }

                // --- SETTLING FORWARD LOCK ---
                const dot = steerX * lookX + steerY * lookY;
                // Allow a small amount of backward movement to let the pack "settle"
                // but keep it primarily forward-facing.
                const backwardLimit = -2;
                if (dot < backwardLimit) {
                    steerX -= lookX * (dot - backwardLimit);
                    steerY -= lookY * (dot - backwardLimit);
                }

                const mag = Math.sqrt(steerX * steerX + steerY * steerY);
                if (mag > 0.1) {
                    const speed = Math.min(data[idx + 6] * 2, mag * 20);
                    const moveAngle = Math.atan2(steerY, steerX);
                    data[idx] += Math.cos(moveAngle) * speed;
                    data[idx + 1] += Math.sin(moveAngle) * speed;
                    data[idx + 7] = look;
                    data[idx + 4] = look + cfg.baseRotation;
                    data[idx + 5] = (mag > 0.3) ? (data[idx + 5] + speed * cfg.walkAnimSpeed) % cfg.walkFrames : 0;
                } else {
                    data[idx + 5] = 0;
                    if (d < cfg.attackRange * 1.5) { data[idx + 7] = look; data[idx + 4] = look + cfg.baseRotation; }
                }

                // --- ATTACK LOGIC ---
                if (d < cfg.attackRange && data[idx + 8] > 0) {
                    if (data[idx + 10] === 0) data[idx + 10] = 0.1;
                    else {
                        const prevF = Math.floor(data[idx + 10]);
                        data[idx + 10] += cfg.attackAnimSpeed;
                        const currF = Math.floor(data[idx + 10]);
                        if (prevF < (cfg.attackFrames / 2) && currF >= (cfg.attackFrames / 2)) {
                            const dmg = cfg.damageMin + Math.random() * (cfg.damageMax - cfg.damageMin);

                            // SHIELD TRIGGER
                            if (!player.shieldActive && player.shieldCooldownRemaining <= 0) {
                                player.shieldActive = true;
                                player.shieldAnimState = 'TURNING_ON';
                                player.shieldFrame = 0;
                                player.shieldHP = player.shieldMaxHP;
                                player.shieldDurationRemaining = sc.shieldDuration;
                            }

                            if (player.shieldActive) {
                                player.shieldHP -= dmg;
                                if (player.shieldHP <= 0) {
                                    player.shieldActive = false;
                                    player.shieldAnimState = 'OFF';
                                    player.shieldCooldownRemaining = sc.shieldCooldown;
                                }
                            } else {
                                player.health -= dmg;
                                if (player.health <= 0) {
                                    softReset();
                                    return;
                                }
                            }
                        }
                        if (data[idx + 10] >= cfg.attackFrames) data[idx + 10] = 0.1;
                    }
                } else { data[idx + 10] = 0; }
            }

            // Update UI
            document.getElementById('player-health-bar').style.width = (player.health / PLAYER_HEALTH_MAX * 100) + '%';

            // Update Damage Numbers
            for (let i = damageNumbers.length - 1; i >= 0; i--) {
                const dn = damageNumbers[i];
                dn.x += dn.vx; dn.y += dn.vy; dn.life -= 0.02;
                if (dn.life <= 0) damageNumbers.splice(i, 1);
            }

            document.getElementById('kills').innerText = `Kills: ${killCount}`;
        }

        function updateSkills(dt, now) {
            const cfg = SKILLS.MulticolorXFlame;

            // Sync Cooldown with Game Speed
            if (skillCooldownRemaining > 0) {
                skillCooldownRemaining -= dt * PERFORMANCE.GAME_SPEED;
                if (skillCooldownRemaining < 0) skillCooldownRemaining = 0;
            }

            const gridOffset = (GRID_DIM * GRID_CELL) / 2;
            const rSq = (cfg.visualSize / 2 * cfg.aoeMult) ** 2;
            const rCell = Math.ceil((cfg.visualSize * cfg.aoeMult) / GRID_CELL);

            for (let i = activeSkills.length - 1; i >= 0; i--) {
                const s = activeSkills[i];
                s.frame += cfg.animSpeedSkill * (dt / 16.6) * PERFORMANCE.GAME_SPEED;

                // Position orbits player
                const x = player.x + Math.cos(s.angle) * cfg.orbitRadius;
                const y = player.y + Math.sin(s.angle) * cfg.orbitRadius;

                // Optimization: Only damage every 4 frames (staggered)
                if (Math.floor(s.frame) % 4 === 0) {
                    const gx = Math.floor((x - player.x + gridOffset) / GRID_CELL);
                    const gy = Math.floor((y - player.y + gridOffset) / GRID_CELL);

                    for (let ox = -rCell; ox <= rCell; ox++) {
                        for (let oy = -rCell; oy <= rCell; oy++) {
                            const cellIdx = (gy + oy) * GRID_DIM + (gx + ox);
                            if (cellIdx < 0 || cellIdx >= heads.length) continue;
                            let ptr = heads[cellIdx];
                            while (ptr !== -1) {
                                const idx = ptr * stride;
                                const enemyH = data[idx + 8];
                                if (enemyH > 0) {
                                    const dx = data[idx] - x, dy = data[idx + 1] - y;
                                    if (dx * dx + dy * dy < rSq) {
                                        data[idx + 8] -= (DAMAGE_PER_POP * cfg.damageMult);
                                        if (data[idx + 8] <= 0) { killCount++; data[idx + 8] = 0; data[idx + 9] = 1; }
                                    }
                                }
                                ptr = next[ptr];
                            }
                        }
                    }
                }

                if (s.frame >= cfg.skillFrames) activeSkills.splice(i, 1);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Sync CSS Background for Zero-Cost Tile Overheads
            if (floorPattern) {
                const bgSize = 18144 * zoom; // 6x base tile size (1024 * 6)
                const bgX = -player.x * zoom + (canvas.width / 2);
                const bgY = -player.y * zoom + (canvas.height / 2);
                document.body.style.backgroundPosition = `${bgX}px ${bgY}px`;
                document.body.style.backgroundSize = `${bgSize}px`;
            }

            const cx = canvas.width / 2, cy = canvas.height / 2;
            ctx.save();
            ctx.translate(cx, cy);
            ctx.scale(zoom, zoom);
            ctx.translate(-player.x, -player.y);

            // Culling bounds (+100px margin)
            const margin = 100 + (Math.max(Enemy.Tiyger.size, Enemy.GalaxyDragon.size) / 2);
            const left = player.x - (cx / zoom) - margin;
            const right = player.x + (cx / zoom) + margin;
            const top = player.y - (cy / zoom) - margin;
            const bottom = player.y + (cy / zoom) + margin;

            // Background Tile Texture (Handled by CSS)

            // Dynamic Smoothing Loop
            smoothedEnemies += (onScreenCount - smoothedEnemies) * 0.15;
            let activeTierIdx = PERFORMANCE.LOD_TIERS.length - 1;
            for (let i = 0; i < PERFORMANCE.LOD_TIERS.length; i++) {
                if (smoothedEnemies <= PERFORMANCE.LOD_TIERS[i].max) {
                    activeTierIdx = i; break;
                }
            }
            const activeTierID = PERFORMANCE.LOD_TIERS[activeTierIdx].id;

            // Update Map Pointers (Lazy update only when needed)
            if (!this.cachedReadyMap || readyMapDirty) {
                this.cachedReadyMap = {
                    Tiyger: { walk: [], death: [], attack: [] },
                    GalaxyDragon: { walk: [], death: [], attack: [] }
                };
                for (const type of ["Tiyger", "GalaxyDragon"]) {
                    const cache = enemyAssets[type].caches;
                    ["walk", "death", "attack"].forEach(anim => {
                        this.cachedReadyMap[type][anim] = PERFORMANCE.LOD_TIERS.map(t => ({ id: t.id, frames: cache[anim][t.id] }));
                    });
                }
                readyMapDirty = false;
            }

            // High-Speed Direct Draw
            const readyMap = this.cachedReadyMap;
            const gridOffset = (GRID_DIM * GRID_CELL) / 2;
            const gxMin = Math.max(0, Math.floor((left - player.x + gridOffset) / GRID_CELL)), gxMax = Math.min(GRID_DIM - 1, Math.floor((right - player.x + gridOffset) / GRID_CELL));
            const gyMin = Math.max(0, Math.floor((top - player.y + gridOffset) / GRID_CELL)), gyMax = Math.min(GRID_DIM - 1, Math.floor((bottom - player.y + gridOffset) / GRID_CELL));

            onScreenCount = 0;
            for (let gy = gyMin; gy <= gyMax; gy++) {
                for (let gx = gxMin; gx <= gxMax; gx++) {
                    let ptr = heads[gy * GRID_DIM + gx];
                    while (ptr !== -1) {
                        const idx = ptr * stride;
                        const x = data[idx], y = data[idx + 1];
                        if (x > left && x < right && y > top && y < bottom) {
                            const h = data[idx + 8], df = data[idx + 9];
                            if (h > 0 || df > 0) {
                                onScreenCount++;
                                const f = Math.floor(data[idx + 5]), rot = data[idx + 4], look = data[idx + 7], af = Math.floor(data[idx + 10]);
                                const typeKey = enemyKeys[data[idx + 11] | 0];
                                const cfg = Enemy[typeKey], assets = enemyAssets[typeKey];

                                const animType = (h <= 0 && df > 0) ? 'death' : (af > 0 ? 'attack' : 'walk');
                                const frameIdx = (h <= 0 && df > 0) ? df : (af > 0 ? af : f);
                                const tiers = readyMap[typeKey][animType];

                                let frameToDraw = null;
                                if (tiers[activeTierIdx].frames && tiers[activeTierIdx].frames[frameIdx]) {
                                    frameToDraw = tiers[activeTierIdx].frames[frameIdx];
                                } else {
                                    let offset = 1;
                                    while (activeTierIdx - offset >= 0 || activeTierIdx + offset < tiers.length) {
                                        const up = activeTierIdx - offset;
                                        if (up >= 0 && tiers[up].frames && tiers[up].frames[frameIdx]) {
                                            frameToDraw = tiers[up].frames[frameIdx]; break;
                                        }
                                        const down = activeTierIdx + offset;
                                        if (down < tiers.length && tiers[down].frames && tiers[down].frames[frameIdx]) {
                                            frameToDraw = tiers[down].frames[frameIdx]; break;
                                        }
                                        offset++;
                                    }
                                }

                                ctx.save();
                                ctx.translate(x, y);
                                ctx.rotate(rot);
                                if (cfg.isSideways && Math.abs(look) < Math.PI / 2) ctx.scale(1, -1);
                                if (h <= 0 && df > 0) ctx.globalAlpha = Math.max(0, 1 - (df / cfg.deathFrames - 0.7) * 3);

                                if (frameToDraw) ctx.drawImage(frameToDraw, -cfg.size / 2, -cfg.size / 2, cfg.size, cfg.size);
                                else {
                                    const sheet = assets[animType];
                                    const sCols = cfg[animType + 'Cols'], sSize = cfg[animType + 'Size'];
                                    ctx.drawImage(sheet, (frameIdx % sCols) * sSize, Math.floor(frameIdx / sCols) * sSize, sSize, sSize, -cfg.size / 2, -cfg.size / 2, cfg.size, cfg.size);
                                }
                                ctx.restore();
                            }
                        }
                        ptr = next[ptr];
                    }
                }
            }

            // --- DRAW SKILLS ---
            if (skillAssets.baked) {
                const sCfg = SKILLS.MulticolorXFlame;
                for (const s of activeSkills) {
                    const f = Math.floor(s.frame) % sCfg.skillFrames;
                    const sx = player.x + Math.cos(s.angle) * sCfg.orbitRadius;
                    const sy = player.y + Math.sin(s.angle) * sCfg.orbitRadius;
                    const frameImg = skillAssets.skillCache[f];
                    if (frameImg) {
                        ctx.drawImage(frameImg, sx - sCfg.visualSize / 2, sy - sCfg.visualSize / 2, sCfg.visualSize, sCfg.visualSize);
                    }
                }
            }

            // Player Visual (SHIP)
            ctx.setTransform(zoom, 0, 0, zoom, cx, cy);
            ctx.save();
            ctx.rotate(player.rotation); // East side faces movement direction
            const sc = SHIP_CONFIG;
            const sf = Math.floor(player.shipFrame);
            const isFull = player.shipState === 'FULL';
            const sImg = isFull ? shipAssets.fullImg : shipAssets.onImg;
            const sFrames = isFull ? sc.fullFrames : sc.onFrames;
            const sCols = isFull ? sc.fullCols : sc.onCols;
            const sSize = isFull ? sc.fullSize : sc.onSize;
            const sCache = isFull ? shipAssets.fullCache : shipAssets.onCache;

            const curFrame = sf % sFrames;
            if (shipAssets.baked && sCache[curFrame]) {
                ctx.drawImage(sCache[curFrame], -sc.visualSize / 2, -sc.visualSize / 2, sc.visualSize, sc.visualSize);
            } else {
                ctx.drawImage(sImg,
                    (curFrame % sCols) * sSize, Math.floor(curFrame / sCols) * sSize, sSize, sSize,
                    -sc.visualSize / 2, -sc.visualSize / 2, sc.visualSize, sc.visualSize
                );
            }

            // --- DRAW SHIELD ---
            if (player.shieldActive && player.shieldAnimState !== 'OFF') {
                const isIsOn = player.shieldAnimState === 'ON';
                const shImg = isIsOn ? shipAssets.shieldOnImg : shipAssets.shieldTurnOnImg;
                const shFrames = isIsOn ? sc.shieldOnFrames : sc.shieldTurnOnFrames;
                const shCols = isIsOn ? sc.shieldOnCols : sc.shieldTurnOnCols;
                const shSize = isIsOn ? sc.shieldOnSize : sc.shieldTurnOnSize;
                const shCache = isIsOn ? shipAssets.shieldOnCache : shipAssets.shieldTurnOnCache;
                const shf = Math.floor(player.shieldFrame) % shFrames;

                if (shipAssets.baked && shCache[shf]) {
                    ctx.drawImage(shCache[shf], -sc.shieldVisualSize / 2, -sc.shieldVisualSize / 2, sc.shieldVisualSize, sc.shieldVisualSize);
                } else {
                    ctx.drawImage(shImg,
                        (shf % shCols) * shSize, Math.floor(shf / shCols) * shSize, shSize, shSize,
                        -sc.shieldVisualSize / 2, -sc.shieldVisualSize / 2, sc.shieldVisualSize, sc.shieldVisualSize
                    );
                }
            }
            ctx.restore();

            // Damage Numbers
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.font = "bold 24px Arial";
            for (const dn of damageNumbers) {
                const sx = (dn.x - player.x) * zoom + cx;
                const sy = (dn.y - player.y) * zoom + cy;
                ctx.fillStyle = `rgba(255, 0, 0, ${dn.life})`;
                ctx.fillText(dn.val, sx, sy);
            }
            ctx.restore();
        }

        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
        window.addEventListener('wheel', (e) => { targetZoom *= e.deltaY > 0 ? 0.9 : 1.1; targetZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, targetZoom)); });

        let loadedCt = 0;
        // 3 assets per enemy + floor + 4 ship assets
        const totalToLoad = (enemyKeys.length * 3) + 1 + 4;
        function onAssetLoad() {
            loadedCt++;
            if (loadedCt === totalToLoad) {
                document.body.style.backgroundImage = `url("${FLOOR_PATH}")`;
                floorPattern = true;
                enemyKeys.forEach(k => buildEnemyCache(k));
                bakeShip();
                init(true);
                canvas.width = window.innerWidth; canvas.height = window.innerHeight;
                let last = 0, f = 0, t = 0;
                let physicsTimeSum = 0;
                let drawTimeSum = 0;

                function loop(now) {
                    const dt = now - last; last = now;
                    t += dt; f++;

                    // Sub-stepping logic for ultra-high speed without tunneling
                    const steps = Math.min(10, Math.ceil(PERFORMANCE.GAME_SPEED));
                    const stepDt = dt * (PERFORMANCE.GAME_SPEED / steps);

                    const sUpdate = performance.now();
                    for (let s = 0; s < steps; s++) {
                        update(stepDt, now + (s * stepDt));
                    }
                    updateSkills(dt, now);
                    physicsTimeSum += (performance.now() - sUpdate);

                    const sDraw = performance.now();
                    draw();
                    drawTimeSum += (performance.now() - sDraw);

                    if (t > 1000) {
                        const avgPhys = (physicsTimeSum / f).toFixed(2);
                        const avgDraw = (drawTimeSum / f).toFixed(2);
                        const msg = `FPS: ${f} | Logic: ${avgPhys}ms | Draw: ${avgDraw}ms | Tasks: ${workerTasksCount}`;
                        document.getElementById('fps').innerText = msg;
                        console.log(`[Perf] ${msg}`);
                        f = 0; t = 0; physicsTimeSum = 0; drawTimeSum = 0;
                    }

                    // --- DRAW SKILL BUTTON UI ---
                    const cfg = SKILLS.MulticolorXFlame;
                    const isCooldown = skillCooldownRemaining > 0;
                    const progress = (cfg.cooldownTime - skillCooldownRemaining) / cfg.cooldownTime;

                    skillBtnCtx.clearRect(0, 0, skillBtnCanvas.width, skillBtnCanvas.height);
                    skillBtnCtx.globalAlpha = isCooldown ? 0.1 + (progress * 0.9) : 1.0;

                    skillBtnFrame = (skillBtnFrame + cfg.animSpeedButton * (dt / 16.6)) % cfg.buttonFrames;
                    const bf = Math.floor(skillBtnFrame);
                    if (skillAssets.baked) {
                        const frameImg = skillAssets.buttonCache[bf];
                        if (frameImg) skillBtnCtx.drawImage(frameImg, 0, 0, skillBtnCanvas.width, skillBtnCanvas.height);
                    }

                    const timerEl = document.getElementById('skill-timer');
                    if (isCooldown) {
                        const targetCount = Math.floor(cfg.cooldownTime / 1000);
                        const currentCount = Math.floor(progress * targetCount);

                        timerEl.innerText = currentCount;
                        timerEl.style.display = 'block';
                    } else {
                        timerEl.style.display = 'none';
                    }

                    requestAnimationFrame(loop);
                }
                requestAnimationFrame(loop);
            }
        }

        const load = (path, img) => {
            img.onload = onAssetLoad;
            img.src = path;
        };

        enemyKeys.forEach(k => {
            load(Enemy[k].walkPath, enemyAssets[k].walk);
            load(Enemy[k].deathPath, enemyAssets[k].death);
            load(Enemy[k].attackPath, enemyAssets[k].attack);
        });

        load(FLOOR_PATH, floorImg);

        // Skill Assets
        const loadSkill = (path, img) => {
            img.onload = () => {
                if (skillAssets.buttonImg.complete && skillAssets.skillImg.complete) {
                    skillAssets.ready = true;
                    bakeSkills();
                }
            };
            img.src = path;
        };

        function bakeSkills() {
            if (skillAssets.baked) return;
            const cfg = SKILLS.MulticolorXFlame;

            // Bake Button (to 256px)
            for (let i = 0; i < cfg.buttonFrames; i++) {
                const can = document.createElement('canvas'); can.width = 256; can.height = 256;
                const cctx = can.getContext('2d');
                cctx.drawImage(skillAssets.buttonImg, (i % cfg.buttonCols) * cfg.buttonSize, Math.floor(i / cfg.buttonCols) * cfg.buttonSize, cfg.buttonSize, cfg.buttonSize, 0, 0, 256, 256);
                skillAssets.buttonCache.push(can);
            }
            // Bake Skill (to 512px)
            for (let i = 0; i < cfg.skillFrames; i++) {
                const can = document.createElement('canvas'); can.width = 512; can.height = 512;
                const cctx = can.getContext('2d');
                cctx.drawImage(skillAssets.skillImg, (i % cfg.skillCols) * cfg.skillSize, Math.floor(i / cfg.skillCols) * cfg.skillSize, cfg.skillSize, cfg.skillSize, 0, 0, 512, 512);
                skillAssets.skillCache.push(can);
            }
            skillAssets.baked = true;
            console.log("Skill animations baked and ready.");
        }

        loadSkill(SKILLS.MulticolorXFlame.buttonSheet, skillAssets.buttonImg);
        loadSkill(SKILLS.MulticolorXFlame.skillSheet, skillAssets.skillImg);

        // Ship Assets
        const loadShip = (path, img) => {
            img.onload = onAssetLoad;
            img.src = path;
        };
        loadShip(SHIP_CONFIG.onPath, shipAssets.onImg);
        loadShip(SHIP_CONFIG.fullPath, shipAssets.fullImg);
        loadShip(SHIP_CONFIG.shieldOnPath, shipAssets.shieldOnImg);
        loadShip(SHIP_CONFIG.shieldTurnOnPath, shipAssets.shieldTurnOnImg);

        function bakeShip() {
            if (shipAssets.baked) return;
            const sc = SHIP_CONFIG;

            const bake = (img, frames, cols, size, targetCache, targetSize) => {
                for (let i = 0; i < frames; i++) {
                    const can = document.createElement('canvas'); can.width = targetSize; can.height = targetSize;
                    const cctx = can.getContext('2d');
                    cctx.drawImage(img, (i % cols) * size, Math.floor(i / cols) * size, size, size, 0, 0, targetSize, targetSize);
                    targetCache.push(can);
                }
            };

            bake(shipAssets.onImg, sc.onFrames, sc.onCols, sc.onSize, shipAssets.onCache, 512);
            bake(shipAssets.fullImg, sc.fullFrames, sc.fullCols, sc.fullSize, shipAssets.fullCache, 512);
            bake(shipAssets.shieldOnImg, sc.shieldOnFrames, sc.shieldOnCols, sc.shieldOnSize, shipAssets.shieldOnCache, 768);
            bake(shipAssets.shieldTurnOnImg, sc.shieldTurnOnFrames, sc.shieldTurnOnCols, sc.shieldTurnOnSize, shipAssets.shieldTurnOnCache, 512);

            shipAssets.baked = true;
            console.log("Ship animations baked and ready.");
        }

        document.getElementById('skill-button-container').addEventListener('click', triggerSkill);

        // Speed Controller Logic
        const slider = document.getElementById('speed-slider');
        const speedVal = document.getElementById('speed-val');
        slider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            PERFORMANCE.GAME_SPEED = val;
            speedVal.innerText = val.toFixed(1) + 'x';
        });
    </script>
</body>

</html>