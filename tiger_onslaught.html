<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiger Onslaught - Idle RPG Demo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: radial-gradient(circle, #1a1a1a 0%, #000 100%);
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.7);
        }

        h1 {
            margin: 0;
            font-size: 24px;
            letter-spacing: 2px;
            color: #ffa500;
        }

        p {
            margin: 5px 0;
            opacity: 0.8;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h1>TIGER ONSLAUGHT</h1>
        <p>They are coming...</p>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        /**
         * Tiger Onslaught
         * A demo showing multiple animated tigers running towards a central player.
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimization

        // Sprite Configuration
        const SPRITE_PATH = 'img/Figer Walking/Spritesheet/1024x1024/grok-video-c940ad13-8ea0-454d-8b91-76e181b1f208 (10)_1024x1024_sheet.png';
        const TOTAL_FRAMES = 52;
        const COLS = 8;
        const ROWS = 7;
        const FRAME_WIDTH = 1024;
        const FRAME_HEIGHT = 1024;
        const TARGET_SIZE = 225; // Visual size of the tiger (1.5x larger)

        // Game State
        let tigers = [];
        const player = {
            x: window.innerWidth / 2,
            y: window.innerHeight / 2,
            targetX: window.innerWidth / 2,
            targetY: window.innerHeight / 2,
            radius: 20,
            color: '#00ffff',
            pulse: 0
        };

        const spriteImg = new Image();
        spriteImg.src = SPRITE_PATH;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Don't reset player position on resize if mouse is active
        }

        window.addEventListener('resize', resize);
        window.addEventListener('mousemove', (e) => {
            player.targetX = e.clientX;
            player.targetY = e.clientY;
        });

        resize();

        class Tiger {
            constructor() {
                this.spawn();
            }

            spawn() {
                // Spawn on a random edge
                const side = Math.floor(Math.random() * 4);
                const margin = 100;
                if (side === 0) { // Top
                    this.x = Math.random() * canvas.width;
                    this.y = -margin;
                } else if (side === 1) { // Right
                    this.x = canvas.width + margin;
                    this.y = Math.random() * canvas.height;
                } else if (side === 2) { // Bottom
                    this.x = Math.random() * canvas.width;
                    this.y = canvas.height + margin;
                } else { // Left
                    this.x = -margin;
                    this.y = Math.random() * canvas.height;
                }

                this.speed = 2.5 + Math.random() * 2.5;
                this.frame = Math.floor(Math.random() * TOTAL_FRAMES);
                // Sync animation speed with movement speed
                this.animSpeed = (this.speed / 3.5) * 1.2;
                this.rotation = 0;
            }

            update(grid) {
                // Direction to player (mouse)
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const distToPlayer = Math.sqrt(dx * dx + dy * dy);

                // --- STEERING FORCES ---
                let steerX = 0;
                let steerY = 0;

                // 1. BEHAVIOR: CIRCLE FORMATION (Thicker ring for large pack)
                const targetRadius = 400;
                const radiusForce = (distToPlayer - targetRadius) * 0.05;
                if (distToPlayer > 0) {
                    steerX += (dx / distToPlayer) * radiusForce;
                    steerY += (dy / distToPlayer) * radiusForce;
                }

                // 2. BEHAVIOR: SEPARATION (Using Spatial Grid)
                const personalSpace = 120;
                const gx = Math.floor(this.x / GRID_SIZE);
                const gy = Math.floor(this.y / GRID_SIZE);

                // Check 3x3 neighborhood of grid cells
                for (let ox = -1; ox <= 1; ox++) {
                    for (let oy = -1; oy <= 1; oy++) {
                        const cellKey = `${gx + ox},${gy + oy}`;
                        const neighbors = grid[cellKey];
                        if (neighbors) {
                            for (let other of neighbors) {
                                if (other === this) continue;
                                const vx = this.x - other.x;
                                const vy = this.y - other.y;
                                const d = Math.sqrt(vx * vx + vy * vy);
                                if (d < personalSpace && d > 0) {
                                    const force = (personalSpace - d) / personalSpace;
                                    steerX += (vx / d) * force * 3;
                                    steerY += (vy / d) * force * 3;
                                }
                            }
                        }
                    }
                }

                // Apply steering to movement
                const magnitude = Math.sqrt(steerX * steerX + steerY * steerY);

                if (magnitude > 0.1) {
                    const finalAngle = Math.atan2(steerY, steerX);
                    const moveSpeed = Math.min(this.speed, magnitude * 4);
                    this.x += Math.cos(finalAngle) * moveSpeed;
                    this.y += Math.sin(finalAngle) * moveSpeed;

                    const lookAngle = Math.atan2(player.y - this.y, player.x - this.x);
                    this.targetAngle = lookAngle;

                    const targetRot = lookAngle + Math.PI;
                    let diff = targetRot - this.rotation;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    this.rotation += diff * 0.1;
                }

                if (magnitude > 0.3) {
                    this.frame = (this.frame + this.animSpeed) % TOTAL_FRAMES;
                } else {
                    this.frame = 0;
                }
            }

            draw() {
                const f = Math.floor(this.frame);
                const col = f % COLS;
                const row = Math.floor(f / COLS);

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                // If moving towards the right (targetAngle between -PI/2 and PI/2),
                // the rotation (+PI) will make the side-view sprite upside down.
                // We fix this by flipping it vertically in local space.
                if (Math.abs(this.targetAngle) < Math.PI / 2) {
                    ctx.scale(1, -1);
                }

                // Draw sprite
                // Using a slightly larger size to see details
                const size = TARGET_SIZE;
                ctx.drawImage(
                    spriteImg,
                    col * FRAME_WIDTH, row * FRAME_HEIGHT,
                    FRAME_WIDTH, FRAME_HEIGHT,
                    -size / 2, -size / 2,
                    size, size
                );

                ctx.restore();
            }
        }

        // Initialize tigers
        const TIGER_COUNT = 520;
        for (let i = 0; i < TIGER_COUNT; i++) {
            tigers.push(new Tiger());
        }

        // Optimization: Spatial Grid for fast collision/separation
        const GRID_SIZE = 100;
        let grid = {};

        function updateGrid() {
            grid = {};
            for (let t of tigers) {
                const gx = Math.floor(t.x / GRID_SIZE);
                const gy = Math.floor(t.y / GRID_SIZE);
                const key = `${gx},${gy}`;
                if (!grid[key]) grid[key] = [];
                grid[key].push(t);
            }
        }

        function animate(time) {
            // Smoothly move the player visual to the target (mouse)
            player.x += (player.targetX - player.x) * 0.1;
            player.y += (player.targetY - player.y) * 0.1;

            // Update spatial grid
            updateGrid();

            // Clear screen
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Background atmospheric grid
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            const bgGridSize = 200;
            for (let x = (player.x % bgGridSize); x < canvas.width; x += bgGridSize) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for (let y = (player.y % bgGridSize); y < canvas.height; y += bgGridSize) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }

            // Draw Player
            player.pulse = Math.sin(time / 200) * 5;
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius + player.pulse, 0, Math.PI * 2);
            ctx.fillStyle = player.color;
            ctx.shadowColor = player.color;
            ctx.shadowBlur = 30;
            ctx.fill();
            ctx.shadowBlur = 0;

            // Update and draw tigers
            // Note: Update logic now uses the global 'grid' for efficiency
            tigers.forEach(tiger => {
                tiger.update(grid);
                tiger.draw();
            });

            requestAnimationFrame(animate);
        }

        spriteImg.onload = () => {
            requestAnimationFrame(animate);
        };

        // Fallback in case image takes too long or fails to trigger onload correctly (though it should)
        setTimeout(() => {
            if (tigers.length > 0) {
                // already running
            } else {
                requestAnimationFrame(animate);
            }
        }, 3000);
    </script>
</body>

</html>