<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiger Swarm - 10,000 Entities Extreme</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, sans-serif;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 18px;
            color: #ffa500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat {
            font-family: monospace;
            font-size: 12px;
            margin-top: 5px;
            color: #0f0;
        }

        #status {
            color: #fff;
            margin-bottom: 5px;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h1>Tiger Hive Mind</h1>
        <div id="status">Status: Loading Engine...</div>
        <div id="count" class="stat">Entities: 10,000</div>
        <div id="fps" class="stat">FPS: 0</div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        /**
         * TIGER SWARM EXTREME
         * Optimized for 10,000+ entities
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const statusEl = document.getElementById('status');

        // CONFIG
        const ENTITY_COUNT = 10000;
        const TARGET_SIZE = 40;
        const TOTAL_FRAMES = 52;
        const SPRITE_PATH = 'img/Figer%20Walking/Spritesheet/1024x1024/grok-video-c940ad13-8ea0-454d-8b91-76e181b1f208%20(10)_1024x1024_sheet.png';

        // CAMERA
        let zoom = 0.5;
        let viewX = 0;
        let viewY = 0;
        let targetZoom = 0.5;
        const mouse = { x: 0, y: 0 };
        const player = { x: 0, y: 0 };

        // DATA: [x, y, vx, vy, rotation, frame, speed, targetAngle]
        const data = new Float32Array(ENTITY_COUNT * 8);
        const stride = 8;

        // SPATIAL GRID
        const GRID_SIZE = 120;
        const GRID_DIM = 200; // 200x200 cells = 24,000px virtual world
        const heads = new Int32Array(GRID_DIM * GRID_DIM).fill(-1);
        const next = new Int32Array(ENTITY_COUNT);

        // ASSETS
        const spriteSheet = new Image();
        const frameCache = document.createElement('canvas');
        const fCtx = frameCache.getContext('2d');
        const cacheSize = 128; // Size of each cached frame

        function initEntities() {
            for (let i = 0; i < ENTITY_COUNT; i++) {
                const idx = i * stride;
                const angle = Math.random() * Math.PI * 2;
                const dist = 500 + Math.random() * 2000;
                data[idx] = Math.cos(angle) * dist;     // x
                data[idx + 1] = Math.sin(angle) * dist; // y
                data[idx + 6] = 2 + Math.random() * 3;  // speed
                data[idx + 5] = Math.random() * TOTAL_FRAMES; // anim frame
            }
        }

        function buildCache() {
            frameCache.width = cacheSize;
            frameCache.height = cacheSize * TOTAL_FRAMES;
            const sheetCols = 8;
            const sw = 1024;
            const sh = 1024;

            for (let i = 0; i < TOTAL_FRAMES; i++) {
                const col = i % sheetCols;
                const row = Math.floor(i / sheetCols);
                fCtx.drawImage(spriteSheet, col * sw, row * sh, sw, sh, 0, i * cacheSize, cacheSize, cacheSize);
            }
            statusEl.innerText = "Status: Hive Mind Online";
        }

        function update() {
            // Smooth Camera
            zoom += (targetZoom - zoom) * 0.1;
            player.x += (mouse.x - player.x) * 0.1;
            player.y += (mouse.y - player.y) * 0.1;

            // Clear Grid
            heads.fill(-1);

            // Populate Grid
            for (let i = 0; i < ENTITY_COUNT; i++) {
                const idx = i * stride;
                const gx = Math.floor((data[idx] + 12000) / GRID_SIZE);
                const gy = Math.floor((data[idx + 1] + 12000) / GRID_SIZE);
                if (gx >= 0 && gx < GRID_DIM && gy >= 0 && gy < GRID_DIM) {
                    const cIdx = gy * GRID_DIM + gx;
                    next[i] = heads[cIdx];
                    heads[cIdx] = i;
                }
            }

            // Logic
            const targetRadius = 500;
            const personalSpace = 100;
            const pSpaceSq = personalSpace * personalSpace;

            for (let i = 0; i < ENTITY_COUNT; i++) {
                const idx = i * stride;
                const px = data[idx];
                const py = data[idx + 1];

                const dx = player.x - px;
                const dy = player.y - py;
                const dist = Math.sqrt(dx * dx + dy * dy);

                let steerX = 0;
                let steerY = 0;

                // 1. Circle Force
                const radiusForce = (dist - targetRadius) * 0.05;
                if (dist > 0) {
                    steerX += (dx / dist) * radiusForce;
                    steerY += (dy / dist) * radiusForce;
                }

                // 2. Separation
                const gx = Math.floor((px + 12000) / GRID_SIZE);
                const gy = Math.floor((py + 12000) / GRID_SIZE);

                for (let ox = -1; ox <= 1; ox++) {
                    for (let oy = -1; oy <= 1; oy++) {
                        const cIdx = (gy + oy) * GRID_DIM + (gx + ox);
                        if (cIdx < 0 || cIdx >= heads.length) continue;

                        let nIdx = heads[cIdx];
                        while (nIdx !== -1) {
                            if (nIdx !== i) {
                                const oIdx = nIdx * stride;
                                const vx = px - data[oIdx];
                                const vy = py - data[oIdx + 1];
                                const dSq = vx * vx + vy * vy;
                                if (dSq < pSpaceSq && dSq > 0) {
                                    const d = Math.sqrt(dSq);
                                    const f = (personalSpace - d) / personalSpace;
                                    steerX += (vx / d) * f * 4;
                                    steerY += (vy / d) * f * 4;
                                }
                            }
                            nIdx = next[nIdx];
                        }
                    }
                }

                const magnitude = Math.sqrt(steerX * steerX + steerY * steerY);
                if (magnitude > 0.1) {
                    const speed = Math.min(data[idx + 6], magnitude * 3);
                    const moveAngle = Math.atan2(steerY, steerX);
                    data[idx] += Math.cos(moveAngle) * speed;
                    data[idx + 1] += Math.sin(moveAngle) * speed;

                    // Face Target Angle
                    const lookAngle = Math.atan2(player.y - data[idx + 1], player.x - data[idx]);
                    data[idx + 7] = lookAngle; // Set targetAngle for flip logic
                    data[idx + 4] = lookAngle + Math.PI; // rotation

                    // Anim
                    if (magnitude > 0.3) {
                        data[idx + 5] = (data[idx + 5] + speed * 0.1) % TOTAL_FRAMES;
                    } else {
                        data[idx + 5] = 0;
                    }
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(zoom, zoom);
            ctx.translate(-viewX, -viewY);

            // Background Grid
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 2 / zoom;
            for (let gx = -3000; gx < 3000; gx += 500) {
                ctx.beginPath(); ctx.moveTo(gx, -3000); ctx.lineTo(gx, 3000); ctx.stroke();
            }
            for (let gy = -3000; gy < 3000; gy += 500) {
                ctx.beginPath(); ctx.moveTo(-3000, gy); ctx.lineTo(3000, gy); ctx.stroke();
            }

            // Player
            ctx.beginPath();
            ctx.arc(player.x, player.y, 80, 0, Math.PI * 2);
            ctx.fillStyle = "#0ff";
            ctx.fill();

            // Tigers
            const halfSize = TARGET_SIZE / 2;
            for (let i = 0; i < ENTITY_COUNT; i++) {
                const idx = i * stride;
                const x = data[idx];
                const y = data[idx + 1];
                const rot = data[idx + 4];
                const frame = Math.floor(data[idx + 5]);
                const lookAngle = data[idx + 7];

                ctx.setTransform(
                    zoom * Math.cos(rot), zoom * Math.sin(rot),
                    -zoom * Math.sin(rot), zoom * Math.cos(rot),
                    centerX + (x - viewX) * zoom,
                    centerY + (y - viewY) * zoom
                );

                if (Math.abs(lookAngle) < Math.PI / 2) {
                    ctx.scale(1, -1);
                }

                ctx.drawImage(frameCache, 0, frame * cacheSize, cacheSize, cacheSize, -halfSize, -halfSize, TARGET_SIZE, TARGET_SIZE);
            }

            ctx.restore();
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset for UI
        }

        // INPUTS
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            viewX = 0; viewY = 0; // Center on start
        });

        window.addEventListener('wheel', (e) => {
            targetZoom *= e.deltaY > 0 ? 0.9 : 1.1;
            targetZoom = Math.max(0.01, Math.min(2.0, targetZoom));
        });

        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX - canvas.width / 2) / zoom + viewX;
            mouse.y = (e.clientY - canvas.height / 2) / zoom + viewY;
        });

        let isDragging = false;
        let lastDrag = { x: 0, y: 0 };
        window.addEventListener('mousedown', (e) => { isDragging = true; lastDrag = { x: e.clientX, y: e.clientY }; });
        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('mousemove', (e) => {
            if (isDragging) {
                viewX -= (e.clientX - lastDrag.x) / zoom;
                viewY -= (e.clientY - lastDrag.y) / zoom;
                lastDrag = { x: e.clientX, y: e.clientY };
            }
        });

        spriteSheet.onload = () => {
            buildCache();
            initEntities();
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            let lastTime = 0;
            let frames = 0;
            let timer = 0;

            function loop(time) {
                const dt = time - lastTime;
                lastTime = time;
                timer += dt;
                frames++;
                if (timer > 1000) {
                    document.getElementById('fps').innerText = `FPS: ${frames}`;
                    frames = 0;
                    timer = 0;
                }
                update();
                draw();
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        };

        spriteSheet.onerror = () => {
            statusEl.innerText = "Error: Could not load sprite sheet. Check path.";
        };

        spriteSheet.src = SPRITE_PATH;
    </script>
</body>

</html>