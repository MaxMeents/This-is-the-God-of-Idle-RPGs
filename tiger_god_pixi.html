<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiger God - 10,000 Entities (PixiJS)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.75);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #ffaa00;
            color: white;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.3);
            z-index: 100;
        }

        h1 {
            margin: 0;
            font-size: 20px;
            letter-spacing: 2px;
            color: #ffaa00;
            text-transform: uppercase;
        }

        .stat {
            font-family: monospace;
            font-size: 14px;
            margin-top: 8px;
            color: #00ff00;
        }

        .hint {
            color: #888;
            font-size: 12px;
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h1>Tiger Hive Mind</h1>
        <div id="count" class="stat">Entities: 10,000</div>
        <div id="fps" class="stat">FPS: ...</div>
        <div class="hint">Scroll to Zoom | Drag to Move</div>
    </div>

    <!-- Include PixiJS Latest -->
    <script src="https://pixijs.download/v8.6.6/pixi.min.js"></script>

    <script>
        /**
         * Tiger God - High Performance Entity Simulation
         * Powered by PixiJS (WebGL/WebGPU Batching)
         */

        const ENTITY_COUNT = 10000;
        const SPRITE_DATA = {
            path: 'img/Figer Walking/Spritesheet/1024x1024/grok-video-c940ad13-8ea0-454d-8b91-76e181b1f208 (10)_1024x1024_sheet.png',
            totalFrames: 52,
            cols: 8,
            frameWidth: 1024,
            frameHeight: 1024,
            baseScale: 0.1 // 102.4px per tiger approx
        };

        const targetCircleRadius = 500;
        const personalSpace = 70;
        const personalSpaceSq = personalSpace * personalSpace;

        // Initialize PixiJS
        async function run() {
            const app = new PIXI.Application();
            await app.init({
                background: '#050505',
                resizeTo: window,
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true
            });
            document.body.appendChild(app.canvas);

            // Load Sprite Sheet
            const texture = await PIXI.Assets.load(SPRITE_DATA.path);
            const frames = [];
            for (let i = 0; i < SPRITE_DATA.totalFrames; i++) {
                const x = (i % SPRITE_DATA.cols) * SPRITE_DATA.frameWidth;
                const y = Math.floor(i / SPRITE_DATA.cols) * SPRITE_DATA.frameHeight;
                frames.push(new PIXI.Texture({
                    source: texture.source,
                    frame: new PIXI.Rectangle(x, y, SPRITE_DATA.frameWidth, SPRITE_DATA.frameHeight)
                }));
            }

            // Game Layers
            const world = new PIXI.Container();
            app.stage.addChild(world);

            const gridContainer = new PIXI.Container();
            world.addChild(gridContainer);

            // Create 10,000 Tigers
            const tigers = [];
            for (let i = 0; i < ENTITY_COUNT; i++) {
                const tiger = new PIXI.AnimatedSprite(frames);
                tiger.anchor.set(0.5);
                tiger.scale.set(SPRITE_DATA.baseScale * 1.5);

                // Random spawn
                const angle = Math.random() * Math.PI * 2;
                const dist = 1000 + Math.random() * 4000;
                tiger.x = Math.cos(angle) * dist;
                tiger.y = Math.sin(angle) * dist;

                tiger.speed = 3 + Math.random() * 5;
                tiger.animationSpeed = 0.5 + (tiger.speed / 10);
                tiger.stop(); // Manual control

                world.addChild(tiger);
                tigers.push(tiger);
            }

            // Player visual
            const player = new PIXI.Graphics()
                .circle(0, 0, 50)
                .fill({ color: 0x00ffff, alpha: 0.8 });
            world.addChild(player);
            let mouseWorldPos = { x: 0, y: 0 };

            // Spatial Grid Setup
            const GRID_CELL_SIZE = 120;
            let grid = new Map();

            // Camera handling
            let zoom = 0.2;
            let isDragging = false;
            let dragStart = { x: 0, y: 0 };
            window.addEventListener('wheel', (e) => {
                const oldZoom = zoom;
                zoom *= e.deltaY > 0 ? 0.9 : 1.1;
                zoom = Math.max(0.01, Math.min(2, zoom));
                world.scale.set(zoom);
            });
            window.addEventListener('mousedown', (e) => { isDragging = true; dragStart = { x: e.clientX, y: e.clientY }; });
            window.addEventListener('mouseup', () => isDragging = false);
            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    world.x += (e.clientX - dragStart.x);
                    world.y += (e.clientY - dragStart.y);
                    dragStart = { x: e.clientX, y: e.clientY };
                }
                // Calculate world mouse position
                mouseWorldPos.x = (e.clientX - world.x) / zoom;
                mouseWorldPos.y = (e.clientY - world.y) / zoom;
            });

            // Set initial camera
            world.x = app.screen.width / 2;
            world.y = app.screen.height / 2;
            world.scale.set(zoom);

            // FPS Counter
            const fpsEl = document.getElementById('fps');

            // Game Loop
            app.ticker.add((time) => {
                fpsEl.innerText = `FPS: ${Math.round(app.ticker.FPS)}`;

                // Smooth player follow
                player.x += (mouseWorldPos.x - player.x) * 0.1;
                player.y += (mouseWorldPos.y - player.y) * 0.1;

                // 1. Update Grid
                grid.clear();
                for (let i = 0; i < ENTITY_COUNT; i++) {
                    const t = tigers[i];
                    const gx = Math.floor(t.x / GRID_CELL_SIZE);
                    const gy = Math.floor(t.y / GRID_CELL_SIZE);
                    const key = `${gx},${gy}`;
                    if (!grid.has(key)) grid.set(key, []);
                    grid.get(key).push(t);
                }

                // 2. Update Tigers
                for (let i = 0; i < ENTITY_COUNT; i++) {
                    const t = tigers[i];

                    // Direction to player
                    const dx = player.x - t.x;
                    const dy = player.y - t.y;
                    const d = Math.sqrt(dx * dx + dy * dy);

                    let steerX = 0;
                    let steerY = 0;

                    // Circle Formation Force
                    const radiusForce = (d - targetCircleRadius) * 0.05;
                    if (d > 0) {
                        steerX += (dx / d) * radiusForce;
                        steerY += (dy / d) * radiusForce;
                    }

                    // Separation Force (Optimized Neighbor Search)
                    const gx = Math.floor(t.x / GRID_CELL_SIZE);
                    const gy = Math.floor(t.y / GRID_CELL_SIZE);

                    for (let ox = -1; ox <= 1; ox++) {
                        for (let oy = -1; oy <= 1; oy++) {
                            const neighbors = grid.get(`${gx + ox},${gy + oy}`);
                            if (neighbors) {
                                for (let j = 0; j < neighbors.length; j++) {
                                    const other = neighbors[j];
                                    if (other === t) continue;
                                    const vx = t.x - other.x;
                                    const vy = t.y - other.y;
                                    const dSq = vx * vx + vy * vy;
                                    if (dSq < personalSpaceSq && dSq > 0) {
                                        const dist = Math.sqrt(dSq);
                                        const force = (personalSpace - dist) / personalSpace;
                                        steerX += (vx / dist) * force * 5;
                                        steerY += (vy / dist) * force * 5;
                                    }
                                }
                            }
                        }
                    }

                    // Physics Apply
                    const magnitude = Math.sqrt(steerX * steerX + steerY * steerY);
                    if (magnitude > 0.1) {
                        const moveSpeed = Math.min(t.speed, magnitude * 4);
                        const angle = Math.atan2(steerY, steerX);
                        t.x += Math.cos(angle) * moveSpeed;
                        t.y += Math.sin(angle) * moveSpeed;

                        // Rotation logic (Face target)
                        const lookAngle = Math.atan2(player.y - t.y, player.x - t.x);
                        t.rotation = lookAngle + Math.PI;

                        // Vertical flip (fix upside down)
                        if (Math.abs(lookAngle) < Math.PI / 2) {
                            t.scale.y = -Math.abs(t.scale.y);
                        } else {
                            t.scale.y = Math.abs(t.scale.y);
                        }

                        // Animation
                        if (magnitude > 0.3) {
                            t.currentFrame = (t.currentFrame + t.animationSpeed) % SPRITE_DATA.totalFrames;
                        } else {
                            t.currentFrame = 0;
                        }
                    }
                }
            });
        }

        run();
    </script>
</body>

</html>